{"version":3,"file":"@reduxjs_toolkit_query_react.js","names":["ENDPOINT_QUERY","ENDPOINT_MUTATION","ENDPOINT_INFINITEQUERY","isQueryDefinition","isMutationDefinition","isInfiniteQueryDefinition","createNextState","safeAssign","createApi","cache","useLayoutEffect","useEffect","useDispatch","createSelector","useSelector","useStore","rrBatch","rrUseDispatch","rrUseSelector","rrUseStore","_createSelector","Provider"],"sources":["../../@standard-schema/utils/dist/index.js","../../@reduxjs/toolkit/dist/query/rtk-query.modern.mjs","../../@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs"],"sourcesContent":["// src/getDotPath/getDotPath.ts\r\nfunction getDotPath(issue) {\r\n  if (issue.path?.length) {\r\n    let dotPath = \"\";\r\n    for (const item of issue.path) {\r\n      const key = typeof item === \"object\" ? item.key : item;\r\n      if (typeof key === \"string\" || typeof key === \"number\") {\r\n        if (dotPath) {\r\n          dotPath += `.${key}`;\r\n        } else {\r\n          dotPath += key;\r\n        }\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    return dotPath;\r\n  }\r\n  return null;\r\n}\r\n\r\n// src/SchemaError/SchemaError.ts\r\nvar SchemaError = class extends Error {\r\n  /**\r\n   * The schema issues.\r\n   */\r\n  issues;\r\n  /**\r\n   * Creates a schema error with useful information.\r\n   *\r\n   * @param issues The schema issues.\r\n   */\r\n  constructor(issues) {\r\n    super(issues[0].message);\r\n    this.name = \"SchemaError\";\r\n    this.issues = issues;\r\n  }\r\n};\r\nexport {\r\n  SchemaError,\r\n  getDotPath\r\n};\r\n","// src/query/core/apiState.ts\r\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus7) => {\r\n  QueryStatus7[\"uninitialized\"] = \"uninitialized\";\r\n  QueryStatus7[\"pending\"] = \"pending\";\r\n  QueryStatus7[\"fulfilled\"] = \"fulfilled\";\r\n  QueryStatus7[\"rejected\"] = \"rejected\";\r\n  return QueryStatus7;\r\n})(QueryStatus || {});\r\nvar STATUS_UNINITIALIZED = \"uninitialized\" /* uninitialized */;\r\nvar STATUS_PENDING = \"pending\" /* pending */;\r\nvar STATUS_FULFILLED = \"fulfilled\" /* fulfilled */;\r\nvar STATUS_REJECTED = \"rejected\" /* rejected */;\r\nfunction getRequestStatusFlags(status) {\r\n  return {\r\n    status,\r\n    isUninitialized: status === STATUS_UNINITIALIZED,\r\n    isLoading: status === STATUS_PENDING,\r\n    isSuccess: status === STATUS_FULFILLED,\r\n    isError: status === STATUS_REJECTED\r\n  };\r\n}\r\n\r\n// src/query/core/rtkImports.ts\r\nimport { createAction, createSlice, createSelector, createAsyncThunk, combineReducers, createNextState, isAnyOf, isAllOf, isAction, isPending, isRejected, isFulfilled, isRejectedWithValue, isAsyncThunkAction, prepareAutoBatched, SHOULD_AUTOBATCH, isPlainObject, nanoid } from \"@reduxjs/toolkit\";\r\n\r\n// src/query/utils/copyWithStructuralSharing.ts\r\nvar isPlainObject2 = isPlainObject;\r\nfunction copyWithStructuralSharing(oldObj, newObj) {\r\n  if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\r\n    return newObj;\r\n  }\r\n  const newKeys = Object.keys(newObj);\r\n  const oldKeys = Object.keys(oldObj);\r\n  let isSameObject = newKeys.length === oldKeys.length;\r\n  const mergeObj = Array.isArray(newObj) ? [] : {};\r\n  for (const key of newKeys) {\r\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\r\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\r\n  }\r\n  return isSameObject ? oldObj : mergeObj;\r\n}\r\n\r\n// src/query/utils/filterMap.ts\r\nfunction filterMap(array, predicate, mapper) {\r\n  return array.reduce((acc, item, i) => {\r\n    if (predicate(item, i)) {\r\n      acc.push(mapper(item, i));\r\n    }\r\n    return acc;\r\n  }, []).flat();\r\n}\r\n\r\n// src/query/utils/isAbsoluteUrl.ts\r\nfunction isAbsoluteUrl(url) {\r\n  return new RegExp(`(^|:)//`).test(url);\r\n}\r\n\r\n// src/query/utils/isDocumentVisible.ts\r\nfunction isDocumentVisible() {\r\n  if (typeof document === \"undefined\") {\r\n    return true;\r\n  }\r\n  return document.visibilityState !== \"hidden\";\r\n}\r\n\r\n// src/query/utils/isNotNullish.ts\r\nfunction isNotNullish(v) {\r\n  return v != null;\r\n}\r\nfunction filterNullishValues(map) {\r\n  return [...map?.values() ?? []].filter(isNotNullish);\r\n}\r\n\r\n// src/query/utils/isOnline.ts\r\nfunction isOnline() {\r\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\r\n}\r\n\r\n// src/query/utils/joinUrls.ts\r\nvar withoutTrailingSlash = (url) => url.replace(/\\/$/, \"\");\r\nvar withoutLeadingSlash = (url) => url.replace(/^\\//, \"\");\r\nfunction joinUrls(base, url) {\r\n  if (!base) {\r\n    return url;\r\n  }\r\n  if (!url) {\r\n    return base;\r\n  }\r\n  if (isAbsoluteUrl(url)) {\r\n    return url;\r\n  }\r\n  const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\r\n  base = withoutTrailingSlash(base);\r\n  url = withoutLeadingSlash(url);\r\n  return `${base}${delimiter}${url}`;\r\n}\r\n\r\n// src/query/utils/getOrInsert.ts\r\nfunction getOrInsertComputed(map, key, compute) {\r\n  if (map.has(key)) return map.get(key);\r\n  return map.set(key, compute(key)).get(key);\r\n}\r\nvar createNewMap = () => /* @__PURE__ */ new Map();\r\n\r\n// src/query/fetchBaseQuery.ts\r\nvar defaultFetchFn = (...args) => fetch(...args);\r\nvar defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;\r\nvar defaultIsJsonContentType = (headers) => (\r\n  /*applicat*/\r\n  /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\")\r\n);\r\nfunction stripUndefined(obj) {\r\n  if (!isPlainObject(obj)) {\r\n    return obj;\r\n  }\r\n  const copy = {\r\n    ...obj\r\n  };\r\n  for (const [k, v] of Object.entries(copy)) {\r\n    if (v === void 0) delete copy[k];\r\n  }\r\n  return copy;\r\n}\r\nvar isJsonifiable = (body) => typeof body === \"object\" && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\r\nfunction fetchBaseQuery({\r\n  baseUrl,\r\n  prepareHeaders = (x) => x,\r\n  fetchFn = defaultFetchFn,\r\n  paramsSerializer,\r\n  isJsonContentType = defaultIsJsonContentType,\r\n  jsonContentType = \"application/json\",\r\n  jsonReplacer,\r\n  timeout: defaultTimeout,\r\n  responseHandler: globalResponseHandler,\r\n  validateStatus: globalValidateStatus,\r\n  ...baseFetchOptions\r\n} = {}) {\r\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\r\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\r\n  }\r\n  return async (arg, api, extraOptions) => {\r\n    const {\r\n      getState,\r\n      extra,\r\n      endpoint,\r\n      forced,\r\n      type\r\n    } = api;\r\n    let meta;\r\n    let {\r\n      url,\r\n      headers = new Headers(baseFetchOptions.headers),\r\n      params = void 0,\r\n      responseHandler = globalResponseHandler ?? \"json\",\r\n      validateStatus = globalValidateStatus ?? defaultValidateStatus,\r\n      timeout = defaultTimeout,\r\n      ...rest\r\n    } = typeof arg == \"string\" ? {\r\n      url: arg\r\n    } : arg;\r\n    let abortController, signal = api.signal;\r\n    if (timeout) {\r\n      abortController = new AbortController();\r\n      api.signal.addEventListener(\"abort\", abortController.abort);\r\n      signal = abortController.signal;\r\n    }\r\n    let config = {\r\n      ...baseFetchOptions,\r\n      signal,\r\n      ...rest\r\n    };\r\n    headers = new Headers(stripUndefined(headers));\r\n    config.headers = await prepareHeaders(headers, {\r\n      getState,\r\n      arg,\r\n      extra,\r\n      endpoint,\r\n      forced,\r\n      type,\r\n      extraOptions\r\n    }) || headers;\r\n    const bodyIsJsonifiable = isJsonifiable(config.body);\r\n    if (config.body != null && !bodyIsJsonifiable && typeof config.body !== \"string\") {\r\n      config.headers.delete(\"content-type\");\r\n    }\r\n    if (!config.headers.has(\"content-type\") && bodyIsJsonifiable) {\r\n      config.headers.set(\"content-type\", jsonContentType);\r\n    }\r\n    if (bodyIsJsonifiable && isJsonContentType(config.headers)) {\r\n      config.body = JSON.stringify(config.body, jsonReplacer);\r\n    }\r\n    if (!config.headers.has(\"accept\")) {\r\n      if (responseHandler === \"json\") {\r\n        config.headers.set(\"accept\", \"application/json\");\r\n      } else if (responseHandler === \"text\") {\r\n        config.headers.set(\"accept\", \"text/plain, text/html, */*\");\r\n      }\r\n    }\r\n    if (params) {\r\n      const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\r\n      const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\r\n      url += divider + query;\r\n    }\r\n    url = joinUrls(baseUrl, url);\r\n    const request = new Request(url, config);\r\n    const requestClone = new Request(url, config);\r\n    meta = {\r\n      request: requestClone\r\n    };\r\n    let response, timedOut = false, timeoutId = abortController && setTimeout(() => {\r\n      timedOut = true;\r\n      abortController.abort();\r\n    }, timeout);\r\n    try {\r\n      response = await fetchFn(request);\r\n    } catch (e) {\r\n      return {\r\n        error: {\r\n          status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\r\n          error: String(e)\r\n        },\r\n        meta\r\n      };\r\n    } finally {\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n      abortController?.signal.removeEventListener(\"abort\", abortController.abort);\r\n    }\r\n    const responseClone = response.clone();\r\n    meta.response = responseClone;\r\n    let resultData;\r\n    let responseText = \"\";\r\n    try {\r\n      let handleResponseError;\r\n      await Promise.all([\r\n        handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),\r\n        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\r\n        // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\r\n        responseClone.text().then((r) => responseText = r, () => {\r\n        })\r\n      ]);\r\n      if (handleResponseError) throw handleResponseError;\r\n    } catch (e) {\r\n      return {\r\n        error: {\r\n          status: \"PARSING_ERROR\",\r\n          originalStatus: response.status,\r\n          data: responseText,\r\n          error: String(e)\r\n        },\r\n        meta\r\n      };\r\n    }\r\n    return validateStatus(response, resultData) ? {\r\n      data: resultData,\r\n      meta\r\n    } : {\r\n      error: {\r\n        status: response.status,\r\n        data: resultData\r\n      },\r\n      meta\r\n    };\r\n  };\r\n  async function handleResponse(response, responseHandler) {\r\n    if (typeof responseHandler === \"function\") {\r\n      return responseHandler(response);\r\n    }\r\n    if (responseHandler === \"content-type\") {\r\n      responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\r\n    }\r\n    if (responseHandler === \"json\") {\r\n      const text = await response.text();\r\n      return text.length ? JSON.parse(text) : null;\r\n    }\r\n    return response.text();\r\n  }\r\n}\r\n\r\n// src/query/HandledError.ts\r\nvar HandledError = class {\r\n  constructor(value, meta = void 0) {\r\n    this.value = value;\r\n    this.meta = meta;\r\n  }\r\n};\r\n\r\n// src/query/retry.ts\r\nasync function defaultBackoff(attempt = 0, maxRetries = 5, signal) {\r\n  const attempts = Math.min(attempt, maxRetries);\r\n  const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\r\n  await new Promise((resolve, reject) => {\r\n    const timeoutId = setTimeout(() => resolve(), timeout);\r\n    if (signal) {\r\n      const abortHandler = () => {\r\n        clearTimeout(timeoutId);\r\n        reject(new Error(\"Aborted\"));\r\n      };\r\n      if (signal.aborted) {\r\n        clearTimeout(timeoutId);\r\n        reject(new Error(\"Aborted\"));\r\n      } else {\r\n        signal.addEventListener(\"abort\", abortHandler, {\r\n          once: true\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\nfunction fail(error, meta) {\r\n  throw Object.assign(new HandledError({\r\n    error,\r\n    meta\r\n  }), {\r\n    throwImmediately: true\r\n  });\r\n}\r\nfunction failIfAborted(signal) {\r\n  if (signal.aborted) {\r\n    fail({\r\n      status: \"CUSTOM_ERROR\",\r\n      error: \"Aborted\"\r\n    });\r\n  }\r\n}\r\nvar EMPTY_OPTIONS = {};\r\nvar retryWithBackoff = (baseQuery, defaultOptions) => async (args, api, extraOptions) => {\r\n  const possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter((x) => x !== void 0);\r\n  const [maxRetries] = possibleMaxRetries.slice(-1);\r\n  const defaultRetryCondition = (_, __, {\r\n    attempt\r\n  }) => attempt <= maxRetries;\r\n  const options = {\r\n    maxRetries,\r\n    backoff: defaultBackoff,\r\n    retryCondition: defaultRetryCondition,\r\n    ...defaultOptions,\r\n    ...extraOptions\r\n  };\r\n  let retry2 = 0;\r\n  while (true) {\r\n    failIfAborted(api.signal);\r\n    try {\r\n      const result = await baseQuery(args, api, extraOptions);\r\n      if (result.error) {\r\n        throw new HandledError(result);\r\n      }\r\n      return result;\r\n    } catch (e) {\r\n      retry2++;\r\n      if (e.throwImmediately) {\r\n        if (e instanceof HandledError) {\r\n          return e.value;\r\n        }\r\n        throw e;\r\n      }\r\n      if (e instanceof HandledError) {\r\n        if (!options.retryCondition(e.value.error, args, {\r\n          attempt: retry2,\r\n          baseQueryApi: api,\r\n          extraOptions\r\n        })) {\r\n          return e.value;\r\n        }\r\n      } else {\r\n        if (retry2 > options.maxRetries) {\r\n          return {\r\n            error: e\r\n          };\r\n        }\r\n      }\r\n      failIfAborted(api.signal);\r\n      try {\r\n        await options.backoff(retry2, options.maxRetries, api.signal);\r\n      } catch (backoffError) {\r\n        failIfAborted(api.signal);\r\n        throw backoffError;\r\n      }\r\n    }\r\n  }\r\n};\r\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\r\n  fail\r\n});\r\n\r\n// src/query/core/setupListeners.ts\r\nvar INTERNAL_PREFIX = \"__rtkq/\";\r\nvar ONLINE = \"online\";\r\nvar OFFLINE = \"offline\";\r\nvar FOCUS = \"focus\";\r\nvar FOCUSED = \"focused\";\r\nvar VISIBILITYCHANGE = \"visibilitychange\";\r\nvar onFocus = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${FOCUSED}`);\r\nvar onFocusLost = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}un${FOCUSED}`);\r\nvar onOnline = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${ONLINE}`);\r\nvar onOffline = /* @__PURE__ */ createAction(`${INTERNAL_PREFIX}${OFFLINE}`);\r\nvar actions = {\r\n  onFocus,\r\n  onFocusLost,\r\n  onOnline,\r\n  onOffline\r\n};\r\nvar initialized = false;\r\nfunction setupListeners(dispatch, customHandler) {\r\n  function defaultHandler() {\r\n    const [handleFocus, handleFocusLost, handleOnline, handleOffline] = [onFocus, onFocusLost, onOnline, onOffline].map((action) => () => dispatch(action()));\r\n    const handleVisibilityChange = () => {\r\n      if (window.document.visibilityState === \"visible\") {\r\n        handleFocus();\r\n      } else {\r\n        handleFocusLost();\r\n      }\r\n    };\r\n    let unsubscribe = () => {\r\n      initialized = false;\r\n    };\r\n    if (!initialized) {\r\n      if (typeof window !== \"undefined\" && window.addEventListener) {\r\n        let updateListeners2 = function(add) {\r\n          Object.entries(handlers).forEach(([event, handler]) => {\r\n            if (add) {\r\n              window.addEventListener(event, handler, false);\r\n            } else {\r\n              window.removeEventListener(event, handler);\r\n            }\r\n          });\r\n        };\r\n        var updateListeners = updateListeners2;\r\n        const handlers = {\r\n          [FOCUS]: handleFocus,\r\n          [VISIBILITYCHANGE]: handleVisibilityChange,\r\n          [ONLINE]: handleOnline,\r\n          [OFFLINE]: handleOffline\r\n        };\r\n        updateListeners2(true);\r\n        initialized = true;\r\n        unsubscribe = () => {\r\n          updateListeners2(false);\r\n          initialized = false;\r\n        };\r\n      }\r\n    }\r\n    return unsubscribe;\r\n  }\r\n  return customHandler ? customHandler(dispatch, actions) : defaultHandler();\r\n}\r\n\r\n// src/query/endpointDefinitions.ts\r\nvar ENDPOINT_QUERY = \"query\" /* query */;\r\nvar ENDPOINT_MUTATION = \"mutation\" /* mutation */;\r\nvar ENDPOINT_INFINITEQUERY = \"infinitequery\" /* infinitequery */;\r\nfunction isQueryDefinition(e) {\r\n  return e.type === ENDPOINT_QUERY;\r\n}\r\nfunction isMutationDefinition(e) {\r\n  return e.type === ENDPOINT_MUTATION;\r\n}\r\nfunction isInfiniteQueryDefinition(e) {\r\n  return e.type === ENDPOINT_INFINITEQUERY;\r\n}\r\nfunction isAnyQueryDefinition(e) {\r\n  return isQueryDefinition(e) || isInfiniteQueryDefinition(e);\r\n}\r\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\r\n  const finalDescription = isFunction(description) ? description(result, error, queryArg, meta) : description;\r\n  if (finalDescription) {\r\n    return filterMap(finalDescription, isNotNullish, (tag) => assertTagTypes(expandTagDescription(tag)));\r\n  }\r\n  return [];\r\n}\r\nfunction isFunction(t) {\r\n  return typeof t === \"function\";\r\n}\r\nfunction expandTagDescription(description) {\r\n  return typeof description === \"string\" ? {\r\n    type: description\r\n  } : description;\r\n}\r\n\r\n// src/query/utils/immerImports.ts\r\nimport { current, isDraft, applyPatches, original, isDraftable, produceWithPatches, enablePatches } from \"immer\";\r\n\r\n// src/query/core/buildInitiate.ts\r\nimport { formatProdErrorMessage as _formatProdErrorMessage } from \"@reduxjs/toolkit\";\r\n\r\n// src/tsHelpers.ts\r\nfunction asSafePromise(promise, fallback) {\r\n  return promise.catch(fallback);\r\n}\r\n\r\n// src/query/apiTypes.ts\r\nvar getEndpointDefinition = (context, endpointName) => context.endpointDefinitions[endpointName];\r\n\r\n// src/query/core/buildInitiate.ts\r\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\r\nvar isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === \"function\";\r\nfunction buildInitiate({\r\n  serializeQueryArgs,\r\n  queryThunk,\r\n  infiniteQueryThunk,\r\n  mutationThunk,\r\n  api,\r\n  context,\r\n  getInternalState\r\n}) {\r\n  const getRunningQueries = (dispatch) => getInternalState(dispatch)?.runningQueries;\r\n  const getRunningMutations = (dispatch) => getInternalState(dispatch)?.runningMutations;\r\n  const {\r\n    unsubscribeQueryResult,\r\n    removeMutationResult,\r\n    updateSubscriptionOptions\r\n  } = api.internalActions;\r\n  return {\r\n    buildInitiateQuery,\r\n    buildInitiateInfiniteQuery,\r\n    buildInitiateMutation,\r\n    getRunningQueryThunk,\r\n    getRunningMutationThunk,\r\n    getRunningQueriesThunk,\r\n    getRunningMutationsThunk\r\n  };\r\n  function getRunningQueryThunk(endpointName, queryArgs) {\r\n    return (dispatch) => {\r\n      const endpointDefinition = getEndpointDefinition(context, endpointName);\r\n      const queryCacheKey = serializeQueryArgs({\r\n        queryArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      });\r\n      return getRunningQueries(dispatch)?.get(queryCacheKey);\r\n    };\r\n  }\r\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\r\n    return (dispatch) => {\r\n      return getRunningMutations(dispatch)?.get(fixedCacheKeyOrRequestId);\r\n    };\r\n  }\r\n  function getRunningQueriesThunk() {\r\n    return (dispatch) => filterNullishValues(getRunningQueries(dispatch));\r\n  }\r\n  function getRunningMutationsThunk() {\r\n    return (dispatch) => filterNullishValues(getRunningMutations(dispatch));\r\n  }\r\n  function middlewareWarning(dispatch) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      if (middlewareWarning.triggered) return;\r\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\r\n      middlewareWarning.triggered = true;\r\n      if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\r\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\r\nYou must add the middleware for RTK-Query to function correctly!`);\r\n      }\r\n    }\r\n  }\r\n  function buildInitiateAnyQuery(endpointName, endpointDefinition) {\r\n    const queryAction = (arg, {\r\n      subscribe = true,\r\n      forceRefetch,\r\n      subscriptionOptions,\r\n      [forceQueryFnSymbol]: forceQueryFn,\r\n      ...rest\r\n    } = {}) => (dispatch, getState) => {\r\n      const queryCacheKey = serializeQueryArgs({\r\n        queryArgs: arg,\r\n        endpointDefinition,\r\n        endpointName\r\n      });\r\n      let thunk;\r\n      const commonThunkArgs = {\r\n        ...rest,\r\n        type: ENDPOINT_QUERY,\r\n        subscribe,\r\n        forceRefetch,\r\n        subscriptionOptions,\r\n        endpointName,\r\n        originalArgs: arg,\r\n        queryCacheKey,\r\n        [forceQueryFnSymbol]: forceQueryFn\r\n      };\r\n      if (isQueryDefinition(endpointDefinition)) {\r\n        thunk = queryThunk(commonThunkArgs);\r\n      } else {\r\n        const {\r\n          direction,\r\n          initialPageParam\r\n        } = rest;\r\n        thunk = infiniteQueryThunk({\r\n          ...commonThunkArgs,\r\n          // Supply these even if undefined. This helps with a field existence\r\n          // check over in `buildSlice.ts`\r\n          direction,\r\n          initialPageParam\r\n        });\r\n      }\r\n      const selector = api.endpoints[endpointName].select(arg);\r\n      const thunkResult = dispatch(thunk);\r\n      const stateAfter = selector(getState());\r\n      middlewareWarning(dispatch);\r\n      const {\r\n        requestId,\r\n        abort\r\n      } = thunkResult;\r\n      const skippedSynchronously = stateAfter.requestId !== requestId;\r\n      const runningQuery = getRunningQueries(dispatch)?.get(queryCacheKey);\r\n      const selectFromState = () => selector(getState());\r\n      const statePromise = Object.assign(forceQueryFn ? (\r\n        // a query has been forced (upsertQueryData)\r\n        // -> we want to resolve it once data has been written with the data that will be written\r\n        thunkResult.then(selectFromState)\r\n      ) : skippedSynchronously && !runningQuery ? (\r\n        // a query has been skipped due to a condition and we do not have any currently running query\r\n        // -> we want to resolve it immediately with the current data\r\n        Promise.resolve(stateAfter)\r\n      ) : (\r\n        // query just started or one is already in flight\r\n        // -> wait for the running query, then resolve with data from after that\r\n        Promise.all([runningQuery, thunkResult]).then(selectFromState)\r\n      ), {\r\n        arg,\r\n        requestId,\r\n        subscriptionOptions,\r\n        queryCacheKey,\r\n        abort,\r\n        async unwrap() {\r\n          const result = await statePromise;\r\n          if (result.isError) {\r\n            throw result.error;\r\n          }\r\n          return result.data;\r\n        },\r\n        refetch: () => dispatch(queryAction(arg, {\r\n          subscribe: false,\r\n          forceRefetch: true\r\n        })),\r\n        unsubscribe() {\r\n          if (subscribe) dispatch(unsubscribeQueryResult({\r\n            queryCacheKey,\r\n            requestId\r\n          }));\r\n        },\r\n        updateSubscriptionOptions(options) {\r\n          statePromise.subscriptionOptions = options;\r\n          dispatch(updateSubscriptionOptions({\r\n            endpointName,\r\n            requestId,\r\n            queryCacheKey,\r\n            options\r\n          }));\r\n        }\r\n      });\r\n      if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\r\n        const runningQueries = getRunningQueries(dispatch);\r\n        runningQueries.set(queryCacheKey, statePromise);\r\n        statePromise.then(() => {\r\n          runningQueries.delete(queryCacheKey);\r\n        });\r\n      }\r\n      return statePromise;\r\n    };\r\n    return queryAction;\r\n  }\r\n  function buildInitiateQuery(endpointName, endpointDefinition) {\r\n    const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\r\n    return queryAction;\r\n  }\r\n  function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {\r\n    const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);\r\n    return infiniteQueryAction;\r\n  }\r\n  function buildInitiateMutation(endpointName) {\r\n    return (arg, {\r\n      track = true,\r\n      fixedCacheKey\r\n    } = {}) => (dispatch, getState) => {\r\n      const thunk = mutationThunk({\r\n        type: \"mutation\",\r\n        endpointName,\r\n        originalArgs: arg,\r\n        track,\r\n        fixedCacheKey\r\n      });\r\n      const thunkResult = dispatch(thunk);\r\n      middlewareWarning(dispatch);\r\n      const {\r\n        requestId,\r\n        abort,\r\n        unwrap\r\n      } = thunkResult;\r\n      const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({\r\n        data\r\n      })), (error) => ({\r\n        error\r\n      }));\r\n      const reset = () => {\r\n        dispatch(removeMutationResult({\r\n          requestId,\r\n          fixedCacheKey\r\n        }));\r\n      };\r\n      const ret = Object.assign(returnValuePromise, {\r\n        arg: thunkResult.arg,\r\n        requestId,\r\n        abort,\r\n        unwrap,\r\n        reset\r\n      });\r\n      const runningMutations = getRunningMutations(dispatch);\r\n      runningMutations.set(requestId, ret);\r\n      ret.then(() => {\r\n        runningMutations.delete(requestId);\r\n      });\r\n      if (fixedCacheKey) {\r\n        runningMutations.set(fixedCacheKey, ret);\r\n        ret.then(() => {\r\n          if (runningMutations.get(fixedCacheKey) === ret) {\r\n            runningMutations.delete(fixedCacheKey);\r\n          }\r\n        });\r\n      }\r\n      return ret;\r\n    };\r\n  }\r\n}\r\n\r\n// src/query/standardSchema.ts\r\nimport { SchemaError } from \"@standard-schema/utils\";\r\nvar NamedSchemaError = class extends SchemaError {\r\n  constructor(issues, value, schemaName, _bqMeta) {\r\n    super(issues);\r\n    this.value = value;\r\n    this.schemaName = schemaName;\r\n    this._bqMeta = _bqMeta;\r\n  }\r\n};\r\nvar shouldSkip = (skipSchemaValidation, schemaName) => Array.isArray(skipSchemaValidation) ? skipSchemaValidation.includes(schemaName) : !!skipSchemaValidation;\r\nasync function parseWithSchema(schema, data, schemaName, bqMeta) {\r\n  const result = await schema[\"~standard\"].validate(data);\r\n  if (result.issues) {\r\n    throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);\r\n  }\r\n  return result.value;\r\n}\r\n\r\n// src/query/core/buildThunks.ts\r\nfunction defaultTransformResponse(baseQueryReturnValue) {\r\n  return baseQueryReturnValue;\r\n}\r\nvar addShouldAutoBatch = (arg = {}) => {\r\n  return {\r\n    ...arg,\r\n    [SHOULD_AUTOBATCH]: true\r\n  };\r\n};\r\nfunction buildThunks({\r\n  reducerPath,\r\n  baseQuery,\r\n  context: {\r\n    endpointDefinitions\r\n  },\r\n  serializeQueryArgs,\r\n  api,\r\n  assertTagType,\r\n  selectors,\r\n  onSchemaFailure,\r\n  catchSchemaFailure: globalCatchSchemaFailure,\r\n  skipSchemaValidation: globalSkipSchemaValidation\r\n}) {\r\n  const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {\r\n    const endpointDefinition = endpointDefinitions[endpointName];\r\n    const queryCacheKey = serializeQueryArgs({\r\n      queryArgs: arg,\r\n      endpointDefinition,\r\n      endpointName\r\n    });\r\n    dispatch(api.internalActions.queryResultPatched({\r\n      queryCacheKey,\r\n      patches\r\n    }));\r\n    if (!updateProvided) {\r\n      return;\r\n    }\r\n    const newValue = api.endpoints[endpointName].select(arg)(\r\n      // Work around TS 4.1 mismatch\r\n      getState()\r\n    );\r\n    const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);\r\n    dispatch(api.internalActions.updateProvidedBy([{\r\n      queryCacheKey,\r\n      providedTags\r\n    }]));\r\n  };\r\n  function addToStart(items, item, max = 0) {\r\n    const newItems = [item, ...items];\r\n    return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\r\n  }\r\n  function addToEnd(items, item, max = 0) {\r\n    const newItems = [...items, item];\r\n    return max && newItems.length > max ? newItems.slice(1) : newItems;\r\n  }\r\n  const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {\r\n    const endpointDefinition = api.endpoints[endpointName];\r\n    const currentState = endpointDefinition.select(arg)(\r\n      // Work around TS 4.1 mismatch\r\n      getState()\r\n    );\r\n    const ret = {\r\n      patches: [],\r\n      inversePatches: [],\r\n      undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))\r\n    };\r\n    if (currentState.status === STATUS_UNINITIALIZED) {\r\n      return ret;\r\n    }\r\n    let newValue;\r\n    if (\"data\" in currentState) {\r\n      if (isDraftable(currentState.data)) {\r\n        const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);\r\n        ret.patches.push(...patches);\r\n        ret.inversePatches.push(...inversePatches);\r\n        newValue = value;\r\n      } else {\r\n        newValue = updateRecipe(currentState.data);\r\n        ret.patches.push({\r\n          op: \"replace\",\r\n          path: [],\r\n          value: newValue\r\n        });\r\n        ret.inversePatches.push({\r\n          op: \"replace\",\r\n          path: [],\r\n          value: currentState.data\r\n        });\r\n      }\r\n    }\r\n    if (ret.patches.length === 0) {\r\n      return ret;\r\n    }\r\n    dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));\r\n    return ret;\r\n  };\r\n  const upsertQueryData = (endpointName, arg, value) => (dispatch) => {\r\n    const res = dispatch(api.endpoints[endpointName].initiate(arg, {\r\n      subscribe: false,\r\n      forceRefetch: true,\r\n      [forceQueryFnSymbol]: () => ({\r\n        data: value\r\n      })\r\n    }));\r\n    return res;\r\n  };\r\n  const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {\r\n    return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;\r\n  };\r\n  const executeEndpoint = async (arg, {\r\n    signal,\r\n    abort,\r\n    rejectWithValue,\r\n    fulfillWithValue,\r\n    dispatch,\r\n    getState,\r\n    extra\r\n  }) => {\r\n    const endpointDefinition = endpointDefinitions[arg.endpointName];\r\n    const {\r\n      metaSchema,\r\n      skipSchemaValidation = globalSkipSchemaValidation\r\n    } = endpointDefinition;\r\n    const isQuery = arg.type === ENDPOINT_QUERY;\r\n    try {\r\n      let transformResponse = defaultTransformResponse;\r\n      const baseQueryApi = {\r\n        signal,\r\n        abort,\r\n        dispatch,\r\n        getState,\r\n        extra,\r\n        endpoint: arg.endpointName,\r\n        type: arg.type,\r\n        forced: isQuery ? isForcedQuery(arg, getState()) : void 0,\r\n        queryCacheKey: isQuery ? arg.queryCacheKey : void 0\r\n      };\r\n      const forceQueryFn = isQuery ? arg[forceQueryFnSymbol] : void 0;\r\n      let finalQueryReturnValue;\r\n      const fetchPage = async (data, param, maxPages, previous) => {\r\n        if (param == null && data.pages.length) {\r\n          return Promise.resolve({\r\n            data\r\n          });\r\n        }\r\n        const finalQueryArg = {\r\n          queryArg: arg.originalArgs,\r\n          pageParam: param\r\n        };\r\n        const pageResponse = await executeRequest(finalQueryArg);\r\n        const addTo = previous ? addToStart : addToEnd;\r\n        return {\r\n          data: {\r\n            pages: addTo(data.pages, pageResponse.data, maxPages),\r\n            pageParams: addTo(data.pageParams, param, maxPages)\r\n          },\r\n          meta: pageResponse.meta\r\n        };\r\n      };\r\n      async function executeRequest(finalQueryArg) {\r\n        let result;\r\n        const {\r\n          extraOptions,\r\n          argSchema,\r\n          rawResponseSchema,\r\n          responseSchema\r\n        } = endpointDefinition;\r\n        if (argSchema && !shouldSkip(skipSchemaValidation, \"arg\")) {\r\n          finalQueryArg = await parseWithSchema(\r\n            argSchema,\r\n            finalQueryArg,\r\n            \"argSchema\",\r\n            {}\r\n            // we don't have a meta yet, so we can't pass it\r\n          );\r\n        }\r\n        if (forceQueryFn) {\r\n          result = forceQueryFn();\r\n        } else if (endpointDefinition.query) {\r\n          transformResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformResponse\");\r\n          result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);\r\n        } else {\r\n          result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));\r\n        }\r\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\r\n          const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\r\n          let err;\r\n          if (!result) {\r\n            err = `${what} did not return anything.`;\r\n          } else if (typeof result !== \"object\") {\r\n            err = `${what} did not return an object.`;\r\n          } else if (result.error && result.data) {\r\n            err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\r\n          } else if (result.error === void 0 && result.data === void 0) {\r\n            err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\r\n          } else {\r\n            for (const key of Object.keys(result)) {\r\n              if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\r\n                err = `The object returned by ${what} has the unknown property ${key}.`;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          if (err) {\r\n            console.error(`Error encountered handling the endpoint ${arg.endpointName}.\r\n                  ${err}\r\n                  It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\r\n                  Object returned was:`, result);\r\n          }\r\n        }\r\n        if (result.error) throw new HandledError(result.error, result.meta);\r\n        let {\r\n          data\r\n        } = result;\r\n        if (rawResponseSchema && !shouldSkip(skipSchemaValidation, \"rawResponse\")) {\r\n          data = await parseWithSchema(rawResponseSchema, result.data, \"rawResponseSchema\", result.meta);\r\n        }\r\n        let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);\r\n        if (responseSchema && !shouldSkip(skipSchemaValidation, \"response\")) {\r\n          transformedResponse = await parseWithSchema(responseSchema, transformedResponse, \"responseSchema\", result.meta);\r\n        }\r\n        return {\r\n          ...result,\r\n          data: transformedResponse\r\n        };\r\n      }\r\n      if (isQuery && \"infiniteQueryOptions\" in endpointDefinition) {\r\n        const {\r\n          infiniteQueryOptions\r\n        } = endpointDefinition;\r\n        const {\r\n          maxPages = Infinity\r\n        } = infiniteQueryOptions;\r\n        let result;\r\n        const blankData = {\r\n          pages: [],\r\n          pageParams: []\r\n        };\r\n        const cachedData = selectors.selectQueryEntry(getState(), arg.queryCacheKey)?.data;\r\n        const isForcedQueryNeedingRefetch = (\r\n          // arg.forceRefetch\r\n          isForcedQuery(arg, getState()) && !arg.direction\r\n        );\r\n        const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;\r\n        if (\"direction\" in arg && arg.direction && existingData.pages.length) {\r\n          const previous = arg.direction === \"backward\";\r\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\r\n          const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);\r\n          result = await fetchPage(existingData, param, maxPages, previous);\r\n        } else {\r\n          const {\r\n            initialPageParam = infiniteQueryOptions.initialPageParam\r\n          } = arg;\r\n          const cachedPageParams = cachedData?.pageParams ?? [];\r\n          const firstPageParam = cachedPageParams[0] ?? initialPageParam;\r\n          const totalPages = cachedPageParams.length;\r\n          result = await fetchPage(existingData, firstPageParam, maxPages);\r\n          if (forceQueryFn) {\r\n            result = {\r\n              data: result.data.pages[0]\r\n            };\r\n          }\r\n          for (let i = 1; i < totalPages; i++) {\r\n            const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);\r\n            result = await fetchPage(result.data, param, maxPages);\r\n          }\r\n        }\r\n        finalQueryReturnValue = result;\r\n      } else {\r\n        finalQueryReturnValue = await executeRequest(arg.originalArgs);\r\n      }\r\n      if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\") && finalQueryReturnValue.meta) {\r\n        finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, \"metaSchema\", finalQueryReturnValue.meta);\r\n      }\r\n      return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({\r\n        fulfilledTimeStamp: Date.now(),\r\n        baseQueryMeta: finalQueryReturnValue.meta\r\n      }));\r\n    } catch (error) {\r\n      let caughtError = error;\r\n      if (caughtError instanceof HandledError) {\r\n        let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, \"transformErrorResponse\");\r\n        const {\r\n          rawErrorResponseSchema,\r\n          errorResponseSchema\r\n        } = endpointDefinition;\r\n        let {\r\n          value,\r\n          meta\r\n        } = caughtError;\r\n        try {\r\n          if (rawErrorResponseSchema && !shouldSkip(skipSchemaValidation, \"rawErrorResponse\")) {\r\n            value = await parseWithSchema(rawErrorResponseSchema, value, \"rawErrorResponseSchema\", meta);\r\n          }\r\n          if (metaSchema && !shouldSkip(skipSchemaValidation, \"meta\")) {\r\n            meta = await parseWithSchema(metaSchema, meta, \"metaSchema\", meta);\r\n          }\r\n          let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);\r\n          if (errorResponseSchema && !shouldSkip(skipSchemaValidation, \"errorResponse\")) {\r\n            transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, \"errorResponseSchema\", meta);\r\n          }\r\n          return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({\r\n            baseQueryMeta: meta\r\n          }));\r\n        } catch (e) {\r\n          caughtError = e;\r\n        }\r\n      }\r\n      try {\r\n        if (caughtError instanceof NamedSchemaError) {\r\n          const info = {\r\n            endpoint: arg.endpointName,\r\n            arg: arg.originalArgs,\r\n            type: arg.type,\r\n            queryCacheKey: isQuery ? arg.queryCacheKey : void 0\r\n          };\r\n          endpointDefinition.onSchemaFailure?.(caughtError, info);\r\n          onSchemaFailure?.(caughtError, info);\r\n          const {\r\n            catchSchemaFailure = globalCatchSchemaFailure\r\n          } = endpointDefinition;\r\n          if (catchSchemaFailure) {\r\n            return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({\r\n              baseQueryMeta: caughtError._bqMeta\r\n            }));\r\n          }\r\n        }\r\n      } catch (e) {\r\n        caughtError = e;\r\n      }\r\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\r\n        console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\r\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, caughtError);\r\n      } else {\r\n        console.error(caughtError);\r\n      }\r\n      throw caughtError;\r\n    }\r\n  };\r\n  function isForcedQuery(arg, state) {\r\n    const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);\r\n    const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;\r\n    const fulfilledVal = requestState?.fulfilledTimeStamp;\r\n    const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\r\n    if (refetchVal) {\r\n      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\r\n    }\r\n    return false;\r\n  }\r\n  const createQueryThunk = () => {\r\n    const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {\r\n      getPendingMeta({\r\n        arg\r\n      }) {\r\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\r\n        return addShouldAutoBatch({\r\n          startedTimeStamp: Date.now(),\r\n          ...isInfiniteQueryDefinition(endpointDefinition) ? {\r\n            direction: arg.direction\r\n          } : {}\r\n        });\r\n      },\r\n      condition(queryThunkArg, {\r\n        getState\r\n      }) {\r\n        const state = getState();\r\n        const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);\r\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\r\n        const currentArg = queryThunkArg.originalArgs;\r\n        const previousArg = requestState?.originalArgs;\r\n        const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];\r\n        const direction = queryThunkArg.direction;\r\n        if (isUpsertQuery(queryThunkArg)) {\r\n          return true;\r\n        }\r\n        if (requestState?.status === \"pending\") {\r\n          return false;\r\n        }\r\n        if (isForcedQuery(queryThunkArg, state)) {\r\n          return true;\r\n        }\r\n        if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\r\n          currentArg,\r\n          previousArg,\r\n          endpointState: requestState,\r\n          state\r\n        })) {\r\n          return true;\r\n        }\r\n        if (fulfilledVal && !direction) {\r\n          return false;\r\n        }\r\n        return true;\r\n      },\r\n      dispatchConditionRejection: true\r\n    });\r\n    return generatedQueryThunk;\r\n  };\r\n  const queryThunk = createQueryThunk();\r\n  const infiniteQueryThunk = createQueryThunk();\r\n  const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {\r\n    getPendingMeta() {\r\n      return addShouldAutoBatch({\r\n        startedTimeStamp: Date.now()\r\n      });\r\n    }\r\n  });\r\n  const hasTheForce = (options) => \"force\" in options;\r\n  const hasMaxAge = (options) => \"ifOlderThan\" in options;\r\n  const prefetch = (endpointName, arg, options = {}) => (dispatch, getState) => {\r\n    const force = hasTheForce(options) && options.force;\r\n    const maxAge = hasMaxAge(options) && options.ifOlderThan;\r\n    const queryAction = (force2 = true) => {\r\n      const options2 = {\r\n        forceRefetch: force2,\r\n        subscribe: false\r\n      };\r\n      return api.endpoints[endpointName].initiate(arg, options2);\r\n    };\r\n    const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\r\n    if (force) {\r\n      dispatch(queryAction());\r\n    } else if (maxAge) {\r\n      const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\r\n      if (!lastFulfilledTs) {\r\n        dispatch(queryAction());\r\n        return;\r\n      }\r\n      const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\r\n      if (shouldRetrigger) {\r\n        dispatch(queryAction());\r\n      }\r\n    } else {\r\n      dispatch(queryAction(false));\r\n    }\r\n  };\r\n  function matchesEndpoint(endpointName) {\r\n    return (action) => action?.meta?.arg?.endpointName === endpointName;\r\n  }\r\n  function buildMatchThunkActions(thunk, endpointName) {\r\n    return {\r\n      matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),\r\n      matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),\r\n      matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))\r\n    };\r\n  }\r\n  return {\r\n    queryThunk,\r\n    mutationThunk,\r\n    infiniteQueryThunk,\r\n    prefetch,\r\n    updateQueryData,\r\n    upsertQueryData,\r\n    patchQueryData,\r\n    buildMatchThunkActions\r\n  };\r\n}\r\nfunction getNextPageParam(options, {\r\n  pages,\r\n  pageParams\r\n}, queryArg) {\r\n  const lastIndex = pages.length - 1;\r\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);\r\n}\r\nfunction getPreviousPageParam(options, {\r\n  pages,\r\n  pageParams\r\n}, queryArg) {\r\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams, queryArg);\r\n}\r\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\r\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\r\n}\r\n\r\n// src/query/utils/getCurrent.ts\r\nfunction getCurrent(value) {\r\n  return isDraft(value) ? current(value) : value;\r\n}\r\n\r\n// src/query/core/buildSlice.ts\r\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\r\n  const substate = state[queryCacheKey];\r\n  if (substate) {\r\n    update(substate);\r\n  }\r\n}\r\nfunction getMutationCacheKey(id) {\r\n  return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\r\n}\r\nfunction updateMutationSubstateIfExists(state, id, update) {\r\n  const substate = state[getMutationCacheKey(id)];\r\n  if (substate) {\r\n    update(substate);\r\n  }\r\n}\r\nvar initialState = {};\r\nfunction buildSlice({\r\n  reducerPath,\r\n  queryThunk,\r\n  mutationThunk,\r\n  serializeQueryArgs,\r\n  context: {\r\n    endpointDefinitions: definitions,\r\n    apiUid,\r\n    extractRehydrationInfo,\r\n    hasRehydrationInfo\r\n  },\r\n  assertTagType,\r\n  config\r\n}) {\r\n  const resetApiState = createAction(`${reducerPath}/resetApiState`);\r\n  function writePendingCacheEntry(draft, arg, upserting, meta) {\r\n    draft[arg.queryCacheKey] ??= {\r\n      status: STATUS_UNINITIALIZED,\r\n      endpointName: arg.endpointName\r\n    };\r\n    updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\r\n      substate.status = STATUS_PENDING;\r\n      substate.requestId = upserting && substate.requestId ? (\r\n        // for `upsertQuery` **updates**, keep the current `requestId`\r\n        substate.requestId\r\n      ) : (\r\n        // for normal queries or `upsertQuery` **inserts** always update the `requestId`\r\n        meta.requestId\r\n      );\r\n      if (arg.originalArgs !== void 0) {\r\n        substate.originalArgs = arg.originalArgs;\r\n      }\r\n      substate.startedTimeStamp = meta.startedTimeStamp;\r\n      const endpointDefinition = definitions[meta.arg.endpointName];\r\n      if (isInfiniteQueryDefinition(endpointDefinition) && \"direction\" in arg) {\r\n        ;\r\n        substate.direction = arg.direction;\r\n      }\r\n    });\r\n  }\r\n  function writeFulfilledCacheEntry(draft, meta, payload, upserting) {\r\n    updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {\r\n      if (substate.requestId !== meta.requestId && !upserting) return;\r\n      const {\r\n        merge\r\n      } = definitions[meta.arg.endpointName];\r\n      substate.status = STATUS_FULFILLED;\r\n      if (merge) {\r\n        if (substate.data !== void 0) {\r\n          const {\r\n            fulfilledTimeStamp,\r\n            arg,\r\n            baseQueryMeta,\r\n            requestId\r\n          } = meta;\r\n          let newData = createNextState(substate.data, (draftSubstateData) => {\r\n            return merge(draftSubstateData, payload, {\r\n              arg: arg.originalArgs,\r\n              baseQueryMeta,\r\n              fulfilledTimeStamp,\r\n              requestId\r\n            });\r\n          });\r\n          substate.data = newData;\r\n        } else {\r\n          substate.data = payload;\r\n        }\r\n      } else {\r\n        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;\r\n      }\r\n      delete substate.error;\r\n      substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\r\n    });\r\n  }\r\n  const querySlice = createSlice({\r\n    name: `${reducerPath}/queries`,\r\n    initialState,\r\n    reducers: {\r\n      removeQueryResult: {\r\n        reducer(draft, {\r\n          payload: {\r\n            queryCacheKey\r\n          }\r\n        }) {\r\n          delete draft[queryCacheKey];\r\n        },\r\n        prepare: prepareAutoBatched()\r\n      },\r\n      cacheEntriesUpserted: {\r\n        reducer(draft, action) {\r\n          for (const entry of action.payload) {\r\n            const {\r\n              queryDescription: arg,\r\n              value\r\n            } = entry;\r\n            writePendingCacheEntry(draft, arg, true, {\r\n              arg,\r\n              requestId: action.meta.requestId,\r\n              startedTimeStamp: action.meta.timestamp\r\n            });\r\n            writeFulfilledCacheEntry(\r\n              draft,\r\n              {\r\n                arg,\r\n                requestId: action.meta.requestId,\r\n                fulfilledTimeStamp: action.meta.timestamp,\r\n                baseQueryMeta: {}\r\n              },\r\n              value,\r\n              // We know we're upserting here\r\n              true\r\n            );\r\n          }\r\n        },\r\n        prepare: (payload) => {\r\n          const queryDescriptions = payload.map((entry) => {\r\n            const {\r\n              endpointName,\r\n              arg,\r\n              value\r\n            } = entry;\r\n            const endpointDefinition = definitions[endpointName];\r\n            const queryDescription = {\r\n              type: ENDPOINT_QUERY,\r\n              endpointName,\r\n              originalArgs: entry.arg,\r\n              queryCacheKey: serializeQueryArgs({\r\n                queryArgs: arg,\r\n                endpointDefinition,\r\n                endpointName\r\n              })\r\n            };\r\n            return {\r\n              queryDescription,\r\n              value\r\n            };\r\n          });\r\n          const result = {\r\n            payload: queryDescriptions,\r\n            meta: {\r\n              [SHOULD_AUTOBATCH]: true,\r\n              requestId: nanoid(),\r\n              timestamp: Date.now()\r\n            }\r\n          };\r\n          return result;\r\n        }\r\n      },\r\n      queryResultPatched: {\r\n        reducer(draft, {\r\n          payload: {\r\n            queryCacheKey,\r\n            patches\r\n          }\r\n        }) {\r\n          updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {\r\n            substate.data = applyPatches(substate.data, patches.concat());\r\n          });\r\n        },\r\n        prepare: prepareAutoBatched()\r\n      }\r\n    },\r\n    extraReducers(builder) {\r\n      builder.addCase(queryThunk.pending, (draft, {\r\n        meta,\r\n        meta: {\r\n          arg\r\n        }\r\n      }) => {\r\n        const upserting = isUpsertQuery(arg);\r\n        writePendingCacheEntry(draft, arg, upserting, meta);\r\n      }).addCase(queryThunk.fulfilled, (draft, {\r\n        meta,\r\n        payload\r\n      }) => {\r\n        const upserting = isUpsertQuery(meta.arg);\r\n        writeFulfilledCacheEntry(draft, meta, payload, upserting);\r\n      }).addCase(queryThunk.rejected, (draft, {\r\n        meta: {\r\n          condition,\r\n          arg,\r\n          requestId\r\n        },\r\n        error,\r\n        payload\r\n      }) => {\r\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {\r\n          if (condition) {\r\n          } else {\r\n            if (substate.requestId !== requestId) return;\r\n            substate.status = STATUS_REJECTED;\r\n            substate.error = payload ?? error;\r\n          }\r\n        });\r\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\r\n        const {\r\n          queries\r\n        } = extractRehydrationInfo(action);\r\n        for (const [key, entry] of Object.entries(queries)) {\r\n          if (\r\n            // do not rehydrate entries that were currently in flight.\r\n            entry?.status === STATUS_FULFILLED || entry?.status === STATUS_REJECTED\r\n          ) {\r\n            draft[key] = entry;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  });\r\n  const mutationSlice = createSlice({\r\n    name: `${reducerPath}/mutations`,\r\n    initialState,\r\n    reducers: {\r\n      removeMutationResult: {\r\n        reducer(draft, {\r\n          payload\r\n        }) {\r\n          const cacheKey = getMutationCacheKey(payload);\r\n          if (cacheKey in draft) {\r\n            delete draft[cacheKey];\r\n          }\r\n        },\r\n        prepare: prepareAutoBatched()\r\n      }\r\n    },\r\n    extraReducers(builder) {\r\n      builder.addCase(mutationThunk.pending, (draft, {\r\n        meta,\r\n        meta: {\r\n          requestId,\r\n          arg,\r\n          startedTimeStamp\r\n        }\r\n      }) => {\r\n        if (!arg.track) return;\r\n        draft[getMutationCacheKey(meta)] = {\r\n          requestId,\r\n          status: STATUS_PENDING,\r\n          endpointName: arg.endpointName,\r\n          startedTimeStamp\r\n        };\r\n      }).addCase(mutationThunk.fulfilled, (draft, {\r\n        payload,\r\n        meta\r\n      }) => {\r\n        if (!meta.arg.track) return;\r\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\r\n          if (substate.requestId !== meta.requestId) return;\r\n          substate.status = STATUS_FULFILLED;\r\n          substate.data = payload;\r\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\r\n        });\r\n      }).addCase(mutationThunk.rejected, (draft, {\r\n        payload,\r\n        error,\r\n        meta\r\n      }) => {\r\n        if (!meta.arg.track) return;\r\n        updateMutationSubstateIfExists(draft, meta, (substate) => {\r\n          if (substate.requestId !== meta.requestId) return;\r\n          substate.status = STATUS_REJECTED;\r\n          substate.error = payload ?? error;\r\n        });\r\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\r\n        const {\r\n          mutations\r\n        } = extractRehydrationInfo(action);\r\n        for (const [key, entry] of Object.entries(mutations)) {\r\n          if (\r\n            // do not rehydrate entries that were currently in flight.\r\n            (entry?.status === STATUS_FULFILLED || entry?.status === STATUS_REJECTED) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\r\n            key !== entry?.requestId\r\n          ) {\r\n            draft[key] = entry;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  });\r\n  const initialInvalidationState = {\r\n    tags: {},\r\n    keys: {}\r\n  };\r\n  const invalidationSlice = createSlice({\r\n    name: `${reducerPath}/invalidation`,\r\n    initialState: initialInvalidationState,\r\n    reducers: {\r\n      updateProvidedBy: {\r\n        reducer(draft, action) {\r\n          for (const {\r\n            queryCacheKey,\r\n            providedTags\r\n          } of action.payload) {\r\n            removeCacheKeyFromTags(draft, queryCacheKey);\r\n            for (const {\r\n              type,\r\n              id\r\n            } of providedTags) {\r\n              const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\r\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\r\n              if (!alreadySubscribed) {\r\n                subscribedQueries.push(queryCacheKey);\r\n              }\r\n            }\r\n            draft.keys[queryCacheKey] = providedTags;\r\n          }\r\n        },\r\n        prepare: prepareAutoBatched()\r\n      }\r\n    },\r\n    extraReducers(builder) {\r\n      builder.addCase(querySlice.actions.removeQueryResult, (draft, {\r\n        payload: {\r\n          queryCacheKey\r\n        }\r\n      }) => {\r\n        removeCacheKeyFromTags(draft, queryCacheKey);\r\n      }).addMatcher(hasRehydrationInfo, (draft, action) => {\r\n        const {\r\n          provided\r\n        } = extractRehydrationInfo(action);\r\n        for (const [type, incomingTags] of Object.entries(provided.tags ?? {})) {\r\n          for (const [id, cacheKeys] of Object.entries(incomingTags)) {\r\n            const subscribedQueries = (draft.tags[type] ??= {})[id || \"__internal_without_id\"] ??= [];\r\n            for (const queryCacheKey of cacheKeys) {\r\n              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\r\n              if (!alreadySubscribed) {\r\n                subscribedQueries.push(queryCacheKey);\r\n              }\r\n              draft.keys[queryCacheKey] = provided.keys[queryCacheKey];\r\n            }\r\n          }\r\n        }\r\n      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {\r\n        writeProvidedTagsForQueries(draft, [action]);\r\n      }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {\r\n        const mockActions = action.payload.map(({\r\n          queryDescription,\r\n          value\r\n        }) => {\r\n          return {\r\n            type: \"UNKNOWN\",\r\n            payload: value,\r\n            meta: {\r\n              requestStatus: \"fulfilled\",\r\n              requestId: \"UNKNOWN\",\r\n              arg: queryDescription\r\n            }\r\n          };\r\n        });\r\n        writeProvidedTagsForQueries(draft, mockActions);\r\n      });\r\n    }\r\n  });\r\n  function removeCacheKeyFromTags(draft, queryCacheKey) {\r\n    const existingTags = getCurrent(draft.keys[queryCacheKey] ?? []);\r\n    for (const tag of existingTags) {\r\n      const tagType = tag.type;\r\n      const tagId = tag.id ?? \"__internal_without_id\";\r\n      const tagSubscriptions = draft.tags[tagType]?.[tagId];\r\n      if (tagSubscriptions) {\r\n        draft.tags[tagType][tagId] = getCurrent(tagSubscriptions).filter((qc) => qc !== queryCacheKey);\r\n      }\r\n    }\r\n    delete draft.keys[queryCacheKey];\r\n  }\r\n  function writeProvidedTagsForQueries(draft, actions3) {\r\n    const providedByEntries = actions3.map((action) => {\r\n      const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\r\n      const {\r\n        queryCacheKey\r\n      } = action.meta.arg;\r\n      return {\r\n        queryCacheKey,\r\n        providedTags\r\n      };\r\n    });\r\n    invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));\r\n  }\r\n  const subscriptionSlice = createSlice({\r\n    name: `${reducerPath}/subscriptions`,\r\n    initialState,\r\n    reducers: {\r\n      updateSubscriptionOptions(d, a) {\r\n      },\r\n      unsubscribeQueryResult(d, a) {\r\n      },\r\n      internal_getRTKQSubscriptions() {\r\n      }\r\n    }\r\n  });\r\n  const internalSubscriptionsSlice = createSlice({\r\n    name: `${reducerPath}/internalSubscriptions`,\r\n    initialState,\r\n    reducers: {\r\n      subscriptionsUpdated: {\r\n        reducer(state, action) {\r\n          return applyPatches(state, action.payload);\r\n        },\r\n        prepare: prepareAutoBatched()\r\n      }\r\n    }\r\n  });\r\n  const configSlice = createSlice({\r\n    name: `${reducerPath}/config`,\r\n    initialState: {\r\n      online: isOnline(),\r\n      focused: isDocumentVisible(),\r\n      middlewareRegistered: false,\r\n      ...config\r\n    },\r\n    reducers: {\r\n      middlewareRegistered(state, {\r\n        payload\r\n      }) {\r\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\r\n      }\r\n    },\r\n    extraReducers: (builder) => {\r\n      builder.addCase(onOnline, (state) => {\r\n        state.online = true;\r\n      }).addCase(onOffline, (state) => {\r\n        state.online = false;\r\n      }).addCase(onFocus, (state) => {\r\n        state.focused = true;\r\n      }).addCase(onFocusLost, (state) => {\r\n        state.focused = false;\r\n      }).addMatcher(hasRehydrationInfo, (draft) => ({\r\n        ...draft\r\n      }));\r\n    }\r\n  });\r\n  const combinedReducer = combineReducers({\r\n    queries: querySlice.reducer,\r\n    mutations: mutationSlice.reducer,\r\n    provided: invalidationSlice.reducer,\r\n    subscriptions: internalSubscriptionsSlice.reducer,\r\n    config: configSlice.reducer\r\n  });\r\n  const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);\r\n  const actions2 = {\r\n    ...configSlice.actions,\r\n    ...querySlice.actions,\r\n    ...subscriptionSlice.actions,\r\n    ...internalSubscriptionsSlice.actions,\r\n    ...mutationSlice.actions,\r\n    ...invalidationSlice.actions,\r\n    resetApiState\r\n  };\r\n  return {\r\n    reducer,\r\n    actions: actions2\r\n  };\r\n}\r\n\r\n// src/query/core/buildSelectors.ts\r\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\r\nvar initialSubState = {\r\n  status: STATUS_UNINITIALIZED\r\n};\r\nvar defaultQuerySubState = /* @__PURE__ */ createNextState(initialSubState, () => {\r\n});\r\nvar defaultMutationSubState = /* @__PURE__ */ createNextState(initialSubState, () => {\r\n});\r\nfunction buildSelectors({\r\n  serializeQueryArgs,\r\n  reducerPath,\r\n  createSelector: createSelector2\r\n}) {\r\n  const selectSkippedQuery = (state) => defaultQuerySubState;\r\n  const selectSkippedMutation = (state) => defaultMutationSubState;\r\n  return {\r\n    buildQuerySelector,\r\n    buildInfiniteQuerySelector,\r\n    buildMutationSelector,\r\n    selectInvalidatedBy,\r\n    selectCachedArgsForQuery,\r\n    selectApiState,\r\n    selectQueries,\r\n    selectMutations,\r\n    selectQueryEntry,\r\n    selectConfig\r\n  };\r\n  function withRequestFlags(substate) {\r\n    return {\r\n      ...substate,\r\n      ...getRequestStatusFlags(substate.status)\r\n    };\r\n  }\r\n  function selectApiState(rootState) {\r\n    const state = rootState[reducerPath];\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      if (!state) {\r\n        if (selectApiState.triggered) return state;\r\n        selectApiState.triggered = true;\r\n        console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\r\n      }\r\n    }\r\n    return state;\r\n  }\r\n  function selectQueries(rootState) {\r\n    return selectApiState(rootState)?.queries;\r\n  }\r\n  function selectQueryEntry(rootState, cacheKey) {\r\n    return selectQueries(rootState)?.[cacheKey];\r\n  }\r\n  function selectMutations(rootState) {\r\n    return selectApiState(rootState)?.mutations;\r\n  }\r\n  function selectConfig(rootState) {\r\n    return selectApiState(rootState)?.config;\r\n  }\r\n  function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {\r\n    return (queryArgs) => {\r\n      if (queryArgs === skipToken) {\r\n        return createSelector2(selectSkippedQuery, combiner);\r\n      }\r\n      const serializedArgs = serializeQueryArgs({\r\n        queryArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      });\r\n      const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;\r\n      return createSelector2(selectQuerySubstate, combiner);\r\n    };\r\n  }\r\n  function buildQuerySelector(endpointName, endpointDefinition) {\r\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);\r\n  }\r\n  function buildInfiniteQuerySelector(endpointName, endpointDefinition) {\r\n    const {\r\n      infiniteQueryOptions\r\n    } = endpointDefinition;\r\n    function withInfiniteQueryResultFlags(substate) {\r\n      const stateWithRequestFlags = {\r\n        ...substate,\r\n        ...getRequestStatusFlags(substate.status)\r\n      };\r\n      const {\r\n        isLoading,\r\n        isError,\r\n        direction\r\n      } = stateWithRequestFlags;\r\n      const isForward = direction === \"forward\";\r\n      const isBackward = direction === \"backward\";\r\n      return {\r\n        ...stateWithRequestFlags,\r\n        hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\r\n        hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),\r\n        isFetchingNextPage: isLoading && isForward,\r\n        isFetchingPreviousPage: isLoading && isBackward,\r\n        isFetchNextPageError: isError && isForward,\r\n        isFetchPreviousPageError: isError && isBackward\r\n      };\r\n    }\r\n    return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);\r\n  }\r\n  function buildMutationSelector() {\r\n    return (id) => {\r\n      let mutationId;\r\n      if (typeof id === \"object\") {\r\n        mutationId = getMutationCacheKey(id) ?? skipToken;\r\n      } else {\r\n        mutationId = id;\r\n      }\r\n      const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\r\n      const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\r\n      return createSelector2(finalSelectMutationSubstate, withRequestFlags);\r\n    };\r\n  }\r\n  function selectInvalidatedBy(state, tags) {\r\n    const apiState = state[reducerPath];\r\n    const toInvalidate = /* @__PURE__ */ new Set();\r\n    const finalTags = filterMap(tags, isNotNullish, expandTagDescription);\r\n    for (const tag of finalTags) {\r\n      const provided = apiState.provided.tags[tag.type];\r\n      if (!provided) {\r\n        continue;\r\n      }\r\n      let invalidateSubscriptions = (tag.id !== void 0 ? (\r\n        // id given: invalidate all queries that provide this type & id\r\n        provided[tag.id]\r\n      ) : (\r\n        // no id: invalidate all queries that provide this type\r\n        Object.values(provided).flat()\r\n      )) ?? [];\r\n      for (const invalidate of invalidateSubscriptions) {\r\n        toInvalidate.add(invalidate);\r\n      }\r\n    }\r\n    return Array.from(toInvalidate.values()).flatMap((queryCacheKey) => {\r\n      const querySubState = apiState.queries[queryCacheKey];\r\n      return querySubState ? {\r\n        queryCacheKey,\r\n        endpointName: querySubState.endpointName,\r\n        originalArgs: querySubState.originalArgs\r\n      } : [];\r\n    });\r\n  }\r\n  function selectCachedArgsForQuery(state, queryName) {\r\n    return filterMap(Object.values(selectQueries(state)), (entry) => entry?.endpointName === queryName && entry.status !== STATUS_UNINITIALIZED, (entry) => entry.originalArgs);\r\n  }\r\n  function getHasNextPage(options, data, queryArg) {\r\n    if (!data) return false;\r\n    return getNextPageParam(options, data, queryArg) != null;\r\n  }\r\n  function getHasPreviousPage(options, data, queryArg) {\r\n    if (!data || !options.getPreviousPageParam) return false;\r\n    return getPreviousPageParam(options, data, queryArg) != null;\r\n  }\r\n}\r\n\r\n// src/query/createApi.ts\r\nimport { formatProdErrorMessage as _formatProdErrorMessage2, formatProdErrorMessage as _formatProdErrorMessage22, formatProdErrorMessage as _formatProdErrorMessage3 } from \"@reduxjs/toolkit\";\r\n\r\n// src/query/defaultSerializeQueryArgs.ts\r\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\r\nvar defaultSerializeQueryArgs = ({\r\n  endpointName,\r\n  queryArgs\r\n}) => {\r\n  let serialized = \"\";\r\n  const cached = cache?.get(queryArgs);\r\n  if (typeof cached === \"string\") {\r\n    serialized = cached;\r\n  } else {\r\n    const stringified = JSON.stringify(queryArgs, (key, value) => {\r\n      value = typeof value === \"bigint\" ? {\r\n        $bigint: value.toString()\r\n      } : value;\r\n      value = isPlainObject(value) ? Object.keys(value).sort().reduce((acc, key2) => {\r\n        acc[key2] = value[key2];\r\n        return acc;\r\n      }, {}) : value;\r\n      return value;\r\n    });\r\n    if (isPlainObject(queryArgs)) {\r\n      cache?.set(queryArgs, stringified);\r\n    }\r\n    serialized = stringified;\r\n  }\r\n  return `${endpointName}(${serialized})`;\r\n};\r\n\r\n// src/query/createApi.ts\r\nimport { weakMapMemoize } from \"reselect\";\r\nfunction buildCreateApi(...modules) {\r\n  return function baseCreateApi(options) {\r\n    const extractRehydrationInfo = weakMapMemoize((action) => options.extractRehydrationInfo?.(action, {\r\n      reducerPath: options.reducerPath ?? \"api\"\r\n    }));\r\n    const optionsWithDefaults = {\r\n      reducerPath: \"api\",\r\n      keepUnusedDataFor: 60,\r\n      refetchOnMountOrArgChange: false,\r\n      refetchOnFocus: false,\r\n      refetchOnReconnect: false,\r\n      invalidationBehavior: \"delayed\",\r\n      ...options,\r\n      extractRehydrationInfo,\r\n      serializeQueryArgs(queryArgsApi) {\r\n        let finalSerializeQueryArgs = defaultSerializeQueryArgs;\r\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\r\n          const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\r\n          finalSerializeQueryArgs = (queryArgsApi2) => {\r\n            const initialResult = endpointSQA(queryArgsApi2);\r\n            if (typeof initialResult === \"string\") {\r\n              return initialResult;\r\n            } else {\r\n              return defaultSerializeQueryArgs({\r\n                ...queryArgsApi2,\r\n                queryArgs: initialResult\r\n              });\r\n            }\r\n          };\r\n        } else if (options.serializeQueryArgs) {\r\n          finalSerializeQueryArgs = options.serializeQueryArgs;\r\n        }\r\n        return finalSerializeQueryArgs(queryArgsApi);\r\n      },\r\n      tagTypes: [...options.tagTypes || []]\r\n    };\r\n    const context = {\r\n      endpointDefinitions: {},\r\n      batch(fn) {\r\n        fn();\r\n      },\r\n      apiUid: nanoid(),\r\n      extractRehydrationInfo,\r\n      hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)\r\n    };\r\n    const api = {\r\n      injectEndpoints,\r\n      enhanceEndpoints({\r\n        addTagTypes,\r\n        endpoints\r\n      }) {\r\n        if (addTagTypes) {\r\n          for (const eT of addTagTypes) {\r\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\r\n              ;\r\n              optionsWithDefaults.tagTypes.push(eT);\r\n            }\r\n          }\r\n        }\r\n        if (endpoints) {\r\n          for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {\r\n            if (typeof partialDefinition === \"function\") {\r\n              partialDefinition(getEndpointDefinition(context, endpointName));\r\n            } else {\r\n              Object.assign(getEndpointDefinition(context, endpointName) || {}, partialDefinition);\r\n            }\r\n          }\r\n        }\r\n        return api;\r\n      }\r\n    };\r\n    const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));\r\n    function injectEndpoints(inject) {\r\n      const evaluatedEndpoints = inject.endpoints({\r\n        query: (x) => ({\r\n          ...x,\r\n          type: ENDPOINT_QUERY\r\n        }),\r\n        mutation: (x) => ({\r\n          ...x,\r\n          type: ENDPOINT_MUTATION\r\n        }),\r\n        infiniteQuery: (x) => ({\r\n          ...x,\r\n          type: ENDPOINT_INFINITEQUERY\r\n        })\r\n      });\r\n      for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {\r\n        if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {\r\n          if (inject.overrideExisting === \"throw\") {\r\n            throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage2(39) : `called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\r\n          } else if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\r\n            console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\r\n          }\r\n          continue;\r\n        }\r\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\r\n          if (isInfiniteQueryDefinition(definition)) {\r\n            const {\r\n              infiniteQueryOptions\r\n            } = definition;\r\n            const {\r\n              maxPages,\r\n              getPreviousPageParam: getPreviousPageParam2\r\n            } = infiniteQueryOptions;\r\n            if (typeof maxPages === \"number\") {\r\n              if (maxPages < 1) {\r\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage22(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);\r\n              }\r\n              if (typeof getPreviousPageParam2 !== \"function\") {\r\n                throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage3(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        context.endpointDefinitions[endpointName] = definition;\r\n        for (const m of initializedModules) {\r\n          m.injectEndpoint(endpointName, definition);\r\n        }\r\n      }\r\n      return api;\r\n    }\r\n    return api.injectEndpoints({\r\n      endpoints: options.endpoints\r\n    });\r\n  };\r\n}\r\n\r\n// src/query/fakeBaseQuery.ts\r\nimport { formatProdErrorMessage as _formatProdErrorMessage4 } from \"@reduxjs/toolkit\";\r\nvar _NEVER = /* @__PURE__ */ Symbol();\r\nfunction fakeBaseQuery() {\r\n  return function() {\r\n    throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage4(33) : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\r\n  };\r\n}\r\n\r\n// src/query/tsHelpers.ts\r\nfunction assertCast(v) {\r\n}\r\nfunction safeAssign(target, ...args) {\r\n  return Object.assign(target, ...args);\r\n}\r\n\r\n// src/query/core/buildMiddleware/batchActions.ts\r\nvar buildBatchedActionsHandler = ({\r\n  api,\r\n  queryThunk,\r\n  internalState,\r\n  mwApi\r\n}) => {\r\n  const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\r\n  let previousSubscriptions = null;\r\n  let updateSyncTimer = null;\r\n  const {\r\n    updateSubscriptionOptions,\r\n    unsubscribeQueryResult\r\n  } = api.internalActions;\r\n  const actuallyMutateSubscriptions = (currentSubscriptions, action) => {\r\n    if (updateSubscriptionOptions.match(action)) {\r\n      const {\r\n        queryCacheKey,\r\n        requestId,\r\n        options\r\n      } = action.payload;\r\n      const sub = currentSubscriptions.get(queryCacheKey);\r\n      if (sub?.has(requestId)) {\r\n        sub.set(requestId, options);\r\n      }\r\n      return true;\r\n    }\r\n    if (unsubscribeQueryResult.match(action)) {\r\n      const {\r\n        queryCacheKey,\r\n        requestId\r\n      } = action.payload;\r\n      const sub = currentSubscriptions.get(queryCacheKey);\r\n      if (sub) {\r\n        sub.delete(requestId);\r\n      }\r\n      return true;\r\n    }\r\n    if (api.internalActions.removeQueryResult.match(action)) {\r\n      currentSubscriptions.delete(action.payload.queryCacheKey);\r\n      return true;\r\n    }\r\n    if (queryThunk.pending.match(action)) {\r\n      const {\r\n        meta: {\r\n          arg,\r\n          requestId\r\n        }\r\n      } = action;\r\n      const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\r\n      if (arg.subscribe) {\r\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\r\n      }\r\n      return true;\r\n    }\r\n    let mutated = false;\r\n    if (queryThunk.rejected.match(action)) {\r\n      const {\r\n        meta: {\r\n          condition,\r\n          arg,\r\n          requestId\r\n        }\r\n      } = action;\r\n      if (condition && arg.subscribe) {\r\n        const substate = getOrInsertComputed(currentSubscriptions, arg.queryCacheKey, createNewMap);\r\n        substate.set(requestId, arg.subscriptionOptions ?? substate.get(requestId) ?? {});\r\n        mutated = true;\r\n      }\r\n    }\r\n    return mutated;\r\n  };\r\n  const getSubscriptions = () => internalState.currentSubscriptions;\r\n  const getSubscriptionCount = (queryCacheKey) => {\r\n    const subscriptions = getSubscriptions();\r\n    const subscriptionsForQueryArg = subscriptions.get(queryCacheKey);\r\n    return subscriptionsForQueryArg?.size ?? 0;\r\n  };\r\n  const isRequestSubscribed = (queryCacheKey, requestId) => {\r\n    const subscriptions = getSubscriptions();\r\n    return !!subscriptions?.get(queryCacheKey)?.get(requestId);\r\n  };\r\n  const subscriptionSelectors = {\r\n    getSubscriptions,\r\n    getSubscriptionCount,\r\n    isRequestSubscribed\r\n  };\r\n  function serializeSubscriptions(currentSubscriptions) {\r\n    return JSON.parse(JSON.stringify(Object.fromEntries([...currentSubscriptions].map(([k, v]) => [k, Object.fromEntries(v)]))));\r\n  }\r\n  return (action, mwApi2) => {\r\n    if (!previousSubscriptions) {\r\n      previousSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\r\n    }\r\n    if (api.util.resetApiState.match(action)) {\r\n      previousSubscriptions = {};\r\n      internalState.currentSubscriptions.clear();\r\n      updateSyncTimer = null;\r\n      return [true, false];\r\n    }\r\n    if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\r\n      return [false, subscriptionSelectors];\r\n    }\r\n    const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\r\n    let actionShouldContinue = true;\r\n    if (process.env.NODE_ENV === \"test\" && typeof action.type === \"string\" && action.type === `${api.reducerPath}/getPolling`) {\r\n      return [false, internalState.currentPolls];\r\n    }\r\n    if (didMutate) {\r\n      if (!updateSyncTimer) {\r\n        updateSyncTimer = setTimeout(() => {\r\n          const newSubscriptions = serializeSubscriptions(internalState.currentSubscriptions);\r\n          const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);\r\n          mwApi2.next(api.internalActions.subscriptionsUpdated(patches));\r\n          previousSubscriptions = newSubscriptions;\r\n          updateSyncTimer = null;\r\n        }, 500);\r\n      }\r\n      const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\r\n      const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\r\n      actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\r\n    }\r\n    return [actionShouldContinue, false];\r\n  };\r\n};\r\n\r\n// src/query/core/buildMiddleware/cacheCollection.ts\r\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\r\nvar buildCacheCollectionHandler = ({\r\n  reducerPath,\r\n  api,\r\n  queryThunk,\r\n  context,\r\n  internalState,\r\n  selectors: {\r\n    selectQueryEntry,\r\n    selectConfig\r\n  },\r\n  getRunningQueryThunk,\r\n  mwApi\r\n}) => {\r\n  const {\r\n    removeQueryResult,\r\n    unsubscribeQueryResult,\r\n    cacheEntriesUpserted\r\n  } = api.internalActions;\r\n  const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);\r\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\r\n    const subscriptions = internalState.currentSubscriptions.get(queryCacheKey);\r\n    if (!subscriptions) {\r\n      return false;\r\n    }\r\n    const hasSubscriptions = subscriptions.size > 0;\r\n    return hasSubscriptions;\r\n  }\r\n  const currentRemovalTimeouts = {};\r\n  function abortAllPromises(promiseMap) {\r\n    for (const promise of promiseMap.values()) {\r\n      promise?.abort?.();\r\n    }\r\n  }\r\n  const handler = (action, mwApi2) => {\r\n    const state = mwApi2.getState();\r\n    const config = selectConfig(state);\r\n    if (canTriggerUnsubscribe(action)) {\r\n      let queryCacheKeys;\r\n      if (cacheEntriesUpserted.match(action)) {\r\n        queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);\r\n      } else {\r\n        const {\r\n          queryCacheKey\r\n        } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;\r\n        queryCacheKeys = [queryCacheKey];\r\n      }\r\n      handleUnsubscribeMany(queryCacheKeys, mwApi2, config);\r\n    }\r\n    if (api.util.resetApiState.match(action)) {\r\n      for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {\r\n        if (timeout) clearTimeout(timeout);\r\n        delete currentRemovalTimeouts[key];\r\n      }\r\n      abortAllPromises(internalState.runningQueries);\r\n      abortAllPromises(internalState.runningMutations);\r\n    }\r\n    if (context.hasRehydrationInfo(action)) {\r\n      const {\r\n        queries\r\n      } = context.extractRehydrationInfo(action);\r\n      handleUnsubscribeMany(Object.keys(queries), mwApi2, config);\r\n    }\r\n  };\r\n  function handleUnsubscribeMany(cacheKeys, api2, config) {\r\n    const state = api2.getState();\r\n    for (const queryCacheKey of cacheKeys) {\r\n      const entry = selectQueryEntry(state, queryCacheKey);\r\n      if (entry?.endpointName) {\r\n        handleUnsubscribe(queryCacheKey, entry.endpointName, api2, config);\r\n      }\r\n    }\r\n  }\r\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\r\n    const endpointDefinition = getEndpointDefinition(context, endpointName);\r\n    const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\r\n    if (keepUnusedDataFor === Infinity) {\r\n      return;\r\n    }\r\n    const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\r\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\r\n      const currentTimeout = currentRemovalTimeouts[queryCacheKey];\r\n      if (currentTimeout) {\r\n        clearTimeout(currentTimeout);\r\n      }\r\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {\r\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\r\n          const entry = selectQueryEntry(api2.getState(), queryCacheKey);\r\n          if (entry?.endpointName) {\r\n            const runningQuery = api2.dispatch(getRunningQueryThunk(entry.endpointName, entry.originalArgs));\r\n            runningQuery?.abort();\r\n          }\r\n          api2.dispatch(removeQueryResult({\r\n            queryCacheKey\r\n          }));\r\n        }\r\n        delete currentRemovalTimeouts[queryCacheKey];\r\n      }, finalKeepUnusedDataFor * 1e3);\r\n    }\r\n  }\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/cacheLifecycle.ts\r\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\r\nvar buildCacheLifecycleHandler = ({\r\n  api,\r\n  reducerPath,\r\n  context,\r\n  queryThunk,\r\n  mutationThunk,\r\n  internalState,\r\n  selectors: {\r\n    selectQueryEntry,\r\n    selectApiState\r\n  }\r\n}) => {\r\n  const isQueryThunk = isAsyncThunkAction(queryThunk);\r\n  const isMutationThunk = isAsyncThunkAction(mutationThunk);\r\n  const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);\r\n  const lifecycleMap = {};\r\n  const {\r\n    removeQueryResult,\r\n    removeMutationResult,\r\n    cacheEntriesUpserted\r\n  } = api.internalActions;\r\n  function resolveLifecycleEntry(cacheKey, data, meta) {\r\n    const lifecycle = lifecycleMap[cacheKey];\r\n    if (lifecycle?.valueResolved) {\r\n      lifecycle.valueResolved({\r\n        data,\r\n        meta\r\n      });\r\n      delete lifecycle.valueResolved;\r\n    }\r\n  }\r\n  function removeLifecycleEntry(cacheKey) {\r\n    const lifecycle = lifecycleMap[cacheKey];\r\n    if (lifecycle) {\r\n      delete lifecycleMap[cacheKey];\r\n      lifecycle.cacheEntryRemoved();\r\n    }\r\n  }\r\n  function getActionMetaFields(action) {\r\n    const {\r\n      arg,\r\n      requestId\r\n    } = action.meta;\r\n    const {\r\n      endpointName,\r\n      originalArgs\r\n    } = arg;\r\n    return [endpointName, originalArgs, requestId];\r\n  }\r\n  const handler = (action, mwApi, stateBefore) => {\r\n    const cacheKey = getCacheKey(action);\r\n    function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {\r\n      const oldEntry = selectQueryEntry(stateBefore, cacheKey2);\r\n      const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);\r\n      if (!oldEntry && newEntry) {\r\n        handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);\r\n      }\r\n    }\r\n    if (queryThunk.pending.match(action)) {\r\n      const [endpointName, originalArgs, requestId] = getActionMetaFields(action);\r\n      checkForNewCacheKey(endpointName, cacheKey, requestId, originalArgs);\r\n    } else if (cacheEntriesUpserted.match(action)) {\r\n      for (const {\r\n        queryDescription,\r\n        value\r\n      } of action.payload) {\r\n        const {\r\n          endpointName,\r\n          originalArgs,\r\n          queryCacheKey\r\n        } = queryDescription;\r\n        checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);\r\n        resolveLifecycleEntry(queryCacheKey, value, {});\r\n      }\r\n    } else if (mutationThunk.pending.match(action)) {\r\n      const state = mwApi.getState()[reducerPath].mutations[cacheKey];\r\n      if (state) {\r\n        const [endpointName, originalArgs, requestId] = getActionMetaFields(action);\r\n        handleNewKey(endpointName, originalArgs, cacheKey, mwApi, requestId);\r\n      }\r\n    } else if (isFulfilledThunk(action)) {\r\n      resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);\r\n    } else if (removeQueryResult.match(action) || removeMutationResult.match(action)) {\r\n      removeLifecycleEntry(cacheKey);\r\n    } else if (api.util.resetApiState.match(action)) {\r\n      for (const cacheKey2 of Object.keys(lifecycleMap)) {\r\n        removeLifecycleEntry(cacheKey2);\r\n      }\r\n    }\r\n  };\r\n  function getCacheKey(action) {\r\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\r\n    if (isMutationThunk(action)) {\r\n      return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\r\n    }\r\n    if (removeQueryResult.match(action)) return action.payload.queryCacheKey;\r\n    if (removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\r\n    return \"\";\r\n  }\r\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\r\n    const endpointDefinition = getEndpointDefinition(context, endpointName);\r\n    const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\r\n    if (!onCacheEntryAdded) return;\r\n    const lifecycle = {};\r\n    const cacheEntryRemoved = new Promise((resolve) => {\r\n      lifecycle.cacheEntryRemoved = resolve;\r\n    });\r\n    const cacheDataLoaded = Promise.race([new Promise((resolve) => {\r\n      lifecycle.valueResolved = resolve;\r\n    }), cacheEntryRemoved.then(() => {\r\n      throw neverResolvedError;\r\n    })]);\r\n    cacheDataLoaded.catch(() => {\r\n    });\r\n    lifecycleMap[queryCacheKey] = lifecycle;\r\n    const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);\r\n    const extra = mwApi.dispatch((_, __, extra2) => extra2);\r\n    const lifecycleApi = {\r\n      ...mwApi,\r\n      getCacheEntry: () => selector(mwApi.getState()),\r\n      requestId,\r\n      extra,\r\n      updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\r\n      cacheDataLoaded,\r\n      cacheEntryRemoved\r\n    };\r\n    const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\r\n    Promise.resolve(runningHandler).catch((e) => {\r\n      if (e === neverResolvedError) return;\r\n      throw e;\r\n    });\r\n  }\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/devMiddleware.ts\r\nvar buildDevCheckHandler = ({\r\n  api,\r\n  context: {\r\n    apiUid\r\n  },\r\n  reducerPath\r\n}) => {\r\n  return (action, mwApi) => {\r\n    if (api.util.resetApiState.match(action)) {\r\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\r\n    }\r\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\r\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\r\n        console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\r\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\r\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n// src/query/core/buildMiddleware/invalidationByTags.ts\r\nvar buildInvalidationByTagsHandler = ({\r\n  reducerPath,\r\n  context,\r\n  context: {\r\n    endpointDefinitions\r\n  },\r\n  mutationThunk,\r\n  queryThunk,\r\n  api,\r\n  assertTagType,\r\n  refetchQuery,\r\n  internalState\r\n}) => {\r\n  const {\r\n    removeQueryResult\r\n  } = api.internalActions;\r\n  const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));\r\n  const isQueryEnd = isAnyOf(isFulfilled(queryThunk, mutationThunk), isRejected(queryThunk, mutationThunk));\r\n  let pendingTagInvalidations = [];\r\n  let pendingRequestCount = 0;\r\n  const handler = (action, mwApi) => {\r\n    if (queryThunk.pending.match(action) || mutationThunk.pending.match(action)) {\r\n      pendingRequestCount++;\r\n    }\r\n    if (isQueryEnd(action)) {\r\n      pendingRequestCount = Math.max(0, pendingRequestCount - 1);\r\n    }\r\n    if (isThunkActionWithTags(action)) {\r\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\r\n    } else if (isQueryEnd(action)) {\r\n      invalidateTags([], mwApi);\r\n    } else if (api.util.invalidateTags.match(action)) {\r\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\r\n    }\r\n  };\r\n  function hasPendingRequests() {\r\n    return pendingRequestCount > 0;\r\n  }\r\n  function invalidateTags(newTags, mwApi) {\r\n    const rootState = mwApi.getState();\r\n    const state = rootState[reducerPath];\r\n    pendingTagInvalidations.push(...newTags);\r\n    if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests()) {\r\n      return;\r\n    }\r\n    const tags = pendingTagInvalidations;\r\n    pendingTagInvalidations = [];\r\n    if (tags.length === 0) return;\r\n    const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\r\n    context.batch(() => {\r\n      const valuesArray = Array.from(toInvalidate.values());\r\n      for (const {\r\n        queryCacheKey\r\n      } of valuesArray) {\r\n        const querySubState = state.queries[queryCacheKey];\r\n        const subscriptionSubState = getOrInsertComputed(internalState.currentSubscriptions, queryCacheKey, createNewMap);\r\n        if (querySubState) {\r\n          if (subscriptionSubState.size === 0) {\r\n            mwApi.dispatch(removeQueryResult({\r\n              queryCacheKey\r\n            }));\r\n          } else if (querySubState.status !== STATUS_UNINITIALIZED) {\r\n            mwApi.dispatch(refetchQuery(querySubState));\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/polling.ts\r\nvar buildPollingHandler = ({\r\n  reducerPath,\r\n  queryThunk,\r\n  api,\r\n  refetchQuery,\r\n  internalState\r\n}) => {\r\n  const {\r\n    currentPolls,\r\n    currentSubscriptions\r\n  } = internalState;\r\n  const pendingPollingUpdates = /* @__PURE__ */ new Set();\r\n  let pollingUpdateTimer = null;\r\n  const handler = (action, mwApi) => {\r\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\r\n      schedulePollingUpdate(action.payload.queryCacheKey, mwApi);\r\n    }\r\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\r\n      schedulePollingUpdate(action.meta.arg.queryCacheKey, mwApi);\r\n    }\r\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\r\n      startNextPoll(action.meta.arg, mwApi);\r\n    }\r\n    if (api.util.resetApiState.match(action)) {\r\n      clearPolls();\r\n      if (pollingUpdateTimer) {\r\n        clearTimeout(pollingUpdateTimer);\r\n        pollingUpdateTimer = null;\r\n      }\r\n      pendingPollingUpdates.clear();\r\n    }\r\n  };\r\n  function schedulePollingUpdate(queryCacheKey, api2) {\r\n    pendingPollingUpdates.add(queryCacheKey);\r\n    if (!pollingUpdateTimer) {\r\n      pollingUpdateTimer = setTimeout(() => {\r\n        for (const key of pendingPollingUpdates) {\r\n          updatePollingInterval({\r\n            queryCacheKey: key\r\n          }, api2);\r\n        }\r\n        pendingPollingUpdates.clear();\r\n        pollingUpdateTimer = null;\r\n      }, 0);\r\n    }\r\n  }\r\n  function startNextPoll({\r\n    queryCacheKey\r\n  }, api2) {\r\n    const state = api2.getState()[reducerPath];\r\n    const querySubState = state.queries[queryCacheKey];\r\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\r\n    if (!querySubState || querySubState.status === STATUS_UNINITIALIZED) return;\r\n    const {\r\n      lowestPollingInterval,\r\n      skipPollingIfUnfocused\r\n    } = findLowestPollingInterval(subscriptions);\r\n    if (!Number.isFinite(lowestPollingInterval)) return;\r\n    const currentPoll = currentPolls.get(queryCacheKey);\r\n    if (currentPoll?.timeout) {\r\n      clearTimeout(currentPoll.timeout);\r\n      currentPoll.timeout = void 0;\r\n    }\r\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\r\n    currentPolls.set(queryCacheKey, {\r\n      nextPollTimestamp,\r\n      pollingInterval: lowestPollingInterval,\r\n      timeout: setTimeout(() => {\r\n        if (state.config.focused || !skipPollingIfUnfocused) {\r\n          api2.dispatch(refetchQuery(querySubState));\r\n        }\r\n        startNextPoll({\r\n          queryCacheKey\r\n        }, api2);\r\n      }, lowestPollingInterval)\r\n    });\r\n  }\r\n  function updatePollingInterval({\r\n    queryCacheKey\r\n  }, api2) {\r\n    const state = api2.getState()[reducerPath];\r\n    const querySubState = state.queries[queryCacheKey];\r\n    const subscriptions = currentSubscriptions.get(queryCacheKey);\r\n    if (!querySubState || querySubState.status === STATUS_UNINITIALIZED) {\r\n      return;\r\n    }\r\n    const {\r\n      lowestPollingInterval\r\n    } = findLowestPollingInterval(subscriptions);\r\n    if (process.env.NODE_ENV === \"test\") {\r\n      const updateCounters = currentPolls.pollUpdateCounters ??= {};\r\n      updateCounters[queryCacheKey] ??= 0;\r\n      updateCounters[queryCacheKey]++;\r\n    }\r\n    if (!Number.isFinite(lowestPollingInterval)) {\r\n      cleanupPollForKey(queryCacheKey);\r\n      return;\r\n    }\r\n    const currentPoll = currentPolls.get(queryCacheKey);\r\n    const nextPollTimestamp = Date.now() + lowestPollingInterval;\r\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\r\n      startNextPoll({\r\n        queryCacheKey\r\n      }, api2);\r\n    }\r\n  }\r\n  function cleanupPollForKey(key) {\r\n    const existingPoll = currentPolls.get(key);\r\n    if (existingPoll?.timeout) {\r\n      clearTimeout(existingPoll.timeout);\r\n    }\r\n    currentPolls.delete(key);\r\n  }\r\n  function clearPolls() {\r\n    for (const key of currentPolls.keys()) {\r\n      cleanupPollForKey(key);\r\n    }\r\n  }\r\n  function findLowestPollingInterval(subscribers = /* @__PURE__ */ new Map()) {\r\n    let skipPollingIfUnfocused = false;\r\n    let lowestPollingInterval = Number.POSITIVE_INFINITY;\r\n    for (const entry of subscribers.values()) {\r\n      if (!!entry.pollingInterval) {\r\n        lowestPollingInterval = Math.min(entry.pollingInterval, lowestPollingInterval);\r\n        skipPollingIfUnfocused = entry.skipPollingIfUnfocused || skipPollingIfUnfocused;\r\n      }\r\n    }\r\n    return {\r\n      lowestPollingInterval,\r\n      skipPollingIfUnfocused\r\n    };\r\n  }\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/queryLifecycle.ts\r\nvar buildQueryLifecycleHandler = ({\r\n  api,\r\n  context,\r\n  queryThunk,\r\n  mutationThunk\r\n}) => {\r\n  const isPendingThunk = isPending(queryThunk, mutationThunk);\r\n  const isRejectedThunk = isRejected(queryThunk, mutationThunk);\r\n  const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);\r\n  const lifecycleMap = {};\r\n  const handler = (action, mwApi) => {\r\n    if (isPendingThunk(action)) {\r\n      const {\r\n        requestId,\r\n        arg: {\r\n          endpointName,\r\n          originalArgs\r\n        }\r\n      } = action.meta;\r\n      const endpointDefinition = getEndpointDefinition(context, endpointName);\r\n      const onQueryStarted = endpointDefinition?.onQueryStarted;\r\n      if (onQueryStarted) {\r\n        const lifecycle = {};\r\n        const queryFulfilled = new Promise((resolve, reject) => {\r\n          lifecycle.resolve = resolve;\r\n          lifecycle.reject = reject;\r\n        });\r\n        queryFulfilled.catch(() => {\r\n        });\r\n        lifecycleMap[requestId] = lifecycle;\r\n        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);\r\n        const extra = mwApi.dispatch((_, __, extra2) => extra2);\r\n        const lifecycleApi = {\r\n          ...mwApi,\r\n          getCacheEntry: () => selector(mwApi.getState()),\r\n          requestId,\r\n          extra,\r\n          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\r\n          queryFulfilled\r\n        };\r\n        onQueryStarted(originalArgs, lifecycleApi);\r\n      }\r\n    } else if (isFullfilledThunk(action)) {\r\n      const {\r\n        requestId,\r\n        baseQueryMeta\r\n      } = action.meta;\r\n      lifecycleMap[requestId]?.resolve({\r\n        data: action.payload,\r\n        meta: baseQueryMeta\r\n      });\r\n      delete lifecycleMap[requestId];\r\n    } else if (isRejectedThunk(action)) {\r\n      const {\r\n        requestId,\r\n        rejectedWithValue,\r\n        baseQueryMeta\r\n      } = action.meta;\r\n      lifecycleMap[requestId]?.reject({\r\n        error: action.payload ?? action.error,\r\n        isUnhandledError: !rejectedWithValue,\r\n        meta: baseQueryMeta\r\n      });\r\n      delete lifecycleMap[requestId];\r\n    }\r\n  };\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/windowEventHandling.ts\r\nvar buildWindowEventHandler = ({\r\n  reducerPath,\r\n  context,\r\n  api,\r\n  refetchQuery,\r\n  internalState\r\n}) => {\r\n  const {\r\n    removeQueryResult\r\n  } = api.internalActions;\r\n  const handler = (action, mwApi) => {\r\n    if (onFocus.match(action)) {\r\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\r\n    }\r\n    if (onOnline.match(action)) {\r\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\r\n    }\r\n  };\r\n  function refetchValidQueries(api2, type) {\r\n    const state = api2.getState()[reducerPath];\r\n    const queries = state.queries;\r\n    const subscriptions = internalState.currentSubscriptions;\r\n    context.batch(() => {\r\n      for (const queryCacheKey of subscriptions.keys()) {\r\n        const querySubState = queries[queryCacheKey];\r\n        const subscriptionSubState = subscriptions.get(queryCacheKey);\r\n        if (!subscriptionSubState || !querySubState) continue;\r\n        const values = [...subscriptionSubState.values()];\r\n        const shouldRefetch = values.some((sub) => sub[type] === true) || values.every((sub) => sub[type] === void 0) && state.config[type];\r\n        if (shouldRefetch) {\r\n          if (subscriptionSubState.size === 0) {\r\n            api2.dispatch(removeQueryResult({\r\n              queryCacheKey\r\n            }));\r\n          } else if (querySubState.status !== STATUS_UNINITIALIZED) {\r\n            api2.dispatch(refetchQuery(querySubState));\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return handler;\r\n};\r\n\r\n// src/query/core/buildMiddleware/index.ts\r\nfunction buildMiddleware(input) {\r\n  const {\r\n    reducerPath,\r\n    queryThunk,\r\n    api,\r\n    context,\r\n    getInternalState\r\n  } = input;\r\n  const {\r\n    apiUid\r\n  } = context;\r\n  const actions2 = {\r\n    invalidateTags: createAction(`${reducerPath}/invalidateTags`)\r\n  };\r\n  const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);\r\n  const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\r\n  const middleware = (mwApi) => {\r\n    let initialized2 = false;\r\n    const internalState = getInternalState(mwApi.dispatch);\r\n    const builderArgs = {\r\n      ...input,\r\n      internalState,\r\n      refetchQuery,\r\n      isThisApiSliceAction,\r\n      mwApi\r\n    };\r\n    const handlers = handlerBuilders.map((build) => build(builderArgs));\r\n    const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\r\n    const windowEventsHandler = buildWindowEventHandler(builderArgs);\r\n    return (next) => {\r\n      return (action) => {\r\n        if (!isAction(action)) {\r\n          return next(action);\r\n        }\r\n        if (!initialized2) {\r\n          initialized2 = true;\r\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\r\n        }\r\n        const mwApiWithNext = {\r\n          ...mwApi,\r\n          next\r\n        };\r\n        const stateBefore = mwApi.getState();\r\n        const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\r\n        let res;\r\n        if (actionShouldContinue) {\r\n          res = next(action);\r\n        } else {\r\n          res = internalProbeResult;\r\n        }\r\n        if (!!mwApi.getState()[reducerPath]) {\r\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\r\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\r\n            for (const handler of handlers) {\r\n              handler(action, mwApiWithNext, stateBefore);\r\n            }\r\n          }\r\n        }\r\n        return res;\r\n      };\r\n    };\r\n  };\r\n  return {\r\n    middleware,\r\n    actions: actions2\r\n  };\r\n  function refetchQuery(querySubState) {\r\n    return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {\r\n      subscribe: false,\r\n      forceRefetch: true\r\n    });\r\n  }\r\n}\r\n\r\n// src/query/core/module.ts\r\nvar coreModuleName = /* @__PURE__ */ Symbol();\r\nvar coreModule = ({\r\n  createSelector: createSelector2 = createSelector\r\n} = {}) => ({\r\n  name: coreModuleName,\r\n  init(api, {\r\n    baseQuery,\r\n    tagTypes,\r\n    reducerPath,\r\n    serializeQueryArgs,\r\n    keepUnusedDataFor,\r\n    refetchOnMountOrArgChange,\r\n    refetchOnFocus,\r\n    refetchOnReconnect,\r\n    invalidationBehavior,\r\n    onSchemaFailure,\r\n    catchSchemaFailure,\r\n    skipSchemaValidation\r\n  }, context) {\r\n    enablePatches();\r\n    assertCast(serializeQueryArgs);\r\n    const assertTagType = (tag) => {\r\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\r\n        if (!tagTypes.includes(tag.type)) {\r\n          console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\r\n        }\r\n      }\r\n      return tag;\r\n    };\r\n    Object.assign(api, {\r\n      reducerPath,\r\n      endpoints: {},\r\n      internalActions: {\r\n        onOnline,\r\n        onOffline,\r\n        onFocus,\r\n        onFocusLost\r\n      },\r\n      util: {}\r\n    });\r\n    const selectors = buildSelectors({\r\n      serializeQueryArgs,\r\n      reducerPath,\r\n      createSelector: createSelector2\r\n    });\r\n    const {\r\n      selectInvalidatedBy,\r\n      selectCachedArgsForQuery,\r\n      buildQuerySelector,\r\n      buildInfiniteQuerySelector,\r\n      buildMutationSelector\r\n    } = selectors;\r\n    safeAssign(api.util, {\r\n      selectInvalidatedBy,\r\n      selectCachedArgsForQuery\r\n    });\r\n    const {\r\n      queryThunk,\r\n      infiniteQueryThunk,\r\n      mutationThunk,\r\n      patchQueryData,\r\n      updateQueryData,\r\n      upsertQueryData,\r\n      prefetch,\r\n      buildMatchThunkActions\r\n    } = buildThunks({\r\n      baseQuery,\r\n      reducerPath,\r\n      context,\r\n      api,\r\n      serializeQueryArgs,\r\n      assertTagType,\r\n      selectors,\r\n      onSchemaFailure,\r\n      catchSchemaFailure,\r\n      skipSchemaValidation\r\n    });\r\n    const {\r\n      reducer,\r\n      actions: sliceActions\r\n    } = buildSlice({\r\n      context,\r\n      queryThunk,\r\n      infiniteQueryThunk,\r\n      mutationThunk,\r\n      serializeQueryArgs,\r\n      reducerPath,\r\n      assertTagType,\r\n      config: {\r\n        refetchOnFocus,\r\n        refetchOnReconnect,\r\n        refetchOnMountOrArgChange,\r\n        keepUnusedDataFor,\r\n        reducerPath,\r\n        invalidationBehavior\r\n      }\r\n    });\r\n    safeAssign(api.util, {\r\n      patchQueryData,\r\n      updateQueryData,\r\n      upsertQueryData,\r\n      prefetch,\r\n      resetApiState: sliceActions.resetApiState,\r\n      upsertQueryEntries: sliceActions.cacheEntriesUpserted\r\n    });\r\n    safeAssign(api.internalActions, sliceActions);\r\n    const internalStateMap = /* @__PURE__ */ new WeakMap();\r\n    const getInternalState = (dispatch) => {\r\n      const state = getOrInsertComputed(internalStateMap, dispatch, () => ({\r\n        currentSubscriptions: /* @__PURE__ */ new Map(),\r\n        currentPolls: /* @__PURE__ */ new Map(),\r\n        runningQueries: /* @__PURE__ */ new Map(),\r\n        runningMutations: /* @__PURE__ */ new Map()\r\n      }));\r\n      return state;\r\n    };\r\n    const {\r\n      buildInitiateQuery,\r\n      buildInitiateInfiniteQuery,\r\n      buildInitiateMutation,\r\n      getRunningMutationThunk,\r\n      getRunningMutationsThunk,\r\n      getRunningQueriesThunk,\r\n      getRunningQueryThunk\r\n    } = buildInitiate({\r\n      queryThunk,\r\n      mutationThunk,\r\n      infiniteQueryThunk,\r\n      api,\r\n      serializeQueryArgs,\r\n      context,\r\n      getInternalState\r\n    });\r\n    safeAssign(api.util, {\r\n      getRunningMutationThunk,\r\n      getRunningMutationsThunk,\r\n      getRunningQueryThunk,\r\n      getRunningQueriesThunk\r\n    });\r\n    const {\r\n      middleware,\r\n      actions: middlewareActions\r\n    } = buildMiddleware({\r\n      reducerPath,\r\n      context,\r\n      queryThunk,\r\n      mutationThunk,\r\n      infiniteQueryThunk,\r\n      api,\r\n      assertTagType,\r\n      selectors,\r\n      getRunningQueryThunk,\r\n      getInternalState\r\n    });\r\n    safeAssign(api.util, middlewareActions);\r\n    safeAssign(api, {\r\n      reducer,\r\n      middleware\r\n    });\r\n    return {\r\n      name: coreModuleName,\r\n      injectEndpoint(endpointName, definition) {\r\n        const anyApi = api;\r\n        const endpoint = anyApi.endpoints[endpointName] ??= {};\r\n        if (isQueryDefinition(definition)) {\r\n          safeAssign(endpoint, {\r\n            name: endpointName,\r\n            select: buildQuerySelector(endpointName, definition),\r\n            initiate: buildInitiateQuery(endpointName, definition)\r\n          }, buildMatchThunkActions(queryThunk, endpointName));\r\n        }\r\n        if (isMutationDefinition(definition)) {\r\n          safeAssign(endpoint, {\r\n            name: endpointName,\r\n            select: buildMutationSelector(),\r\n            initiate: buildInitiateMutation(endpointName)\r\n          }, buildMatchThunkActions(mutationThunk, endpointName));\r\n        }\r\n        if (isInfiniteQueryDefinition(definition)) {\r\n          safeAssign(endpoint, {\r\n            name: endpointName,\r\n            select: buildInfiniteQuerySelector(endpointName, definition),\r\n            initiate: buildInitiateInfiniteQuery(endpointName, definition)\r\n          }, buildMatchThunkActions(queryThunk, endpointName));\r\n        }\r\n      }\r\n    };\r\n  }\r\n});\r\n\r\n// src/query/core/index.ts\r\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\r\nexport {\r\n  NamedSchemaError,\r\n  QueryStatus,\r\n  _NEVER,\r\n  buildCreateApi,\r\n  copyWithStructuralSharing,\r\n  coreModule,\r\n  coreModuleName,\r\n  createApi,\r\n  defaultSerializeQueryArgs,\r\n  fakeBaseQuery,\r\n  fetchBaseQuery,\r\n  retry,\r\n  setupListeners,\r\n  skipToken\r\n};\r\n//# sourceMappingURL=rtk-query.modern.mjs.map","// src/query/react/rtkqImports.ts\r\nimport { buildCreateApi, coreModule, copyWithStructuralSharing, setupListeners, QueryStatus, skipToken } from \"@reduxjs/toolkit/query\";\r\n\r\n// src/query/react/module.ts\r\nimport { formatProdErrorMessage as _formatProdErrorMessage3 } from \"@reduxjs/toolkit\";\r\nimport { batch as rrBatch, useDispatch as rrUseDispatch, useSelector as rrUseSelector, useStore as rrUseStore } from \"react-redux\";\r\nimport { createSelector as _createSelector } from \"reselect\";\r\n\r\n// src/query/utils/capitalize.ts\r\nfunction capitalize(str) {\r\n  return str.replace(str[0], str[0].toUpperCase());\r\n}\r\n\r\n// src/query/utils/countObjectKeys.ts\r\nfunction countObjectKeys(obj) {\r\n  let count = 0;\r\n  for (const _key in obj) {\r\n    count++;\r\n  }\r\n  return count;\r\n}\r\n\r\n// src/query/endpointDefinitions.ts\r\nvar ENDPOINT_QUERY = \"query\" /* query */;\r\nvar ENDPOINT_MUTATION = \"mutation\" /* mutation */;\r\nvar ENDPOINT_INFINITEQUERY = \"infinitequery\" /* infinitequery */;\r\nfunction isQueryDefinition(e) {\r\n  return e.type === ENDPOINT_QUERY;\r\n}\r\nfunction isMutationDefinition(e) {\r\n  return e.type === ENDPOINT_MUTATION;\r\n}\r\nfunction isInfiniteQueryDefinition(e) {\r\n  return e.type === ENDPOINT_INFINITEQUERY;\r\n}\r\n\r\n// src/query/tsHelpers.ts\r\nfunction safeAssign(target, ...args) {\r\n  return Object.assign(target, ...args);\r\n}\r\n\r\n// src/query/react/buildHooks.ts\r\nimport { formatProdErrorMessage as _formatProdErrorMessage, formatProdErrorMessage as _formatProdErrorMessage2 } from \"@reduxjs/toolkit\";\r\n\r\n// src/query/react/reactImports.ts\r\nimport { useEffect, useRef, useMemo, useContext, useCallback, useDebugValue, useLayoutEffect, useState } from \"react\";\r\n\r\n// src/query/react/reactReduxImports.ts\r\nimport { shallowEqual, Provider, ReactReduxContext } from \"react-redux\";\r\n\r\n// src/query/react/constants.ts\r\nvar UNINITIALIZED_VALUE = Symbol();\r\n\r\n// src/query/react/useSerializedStableValue.ts\r\nfunction useStableQueryArgs(queryArgs) {\r\n  const cache = useRef(queryArgs);\r\n  const copy = useMemo(() => copyWithStructuralSharing(cache.current, queryArgs), [queryArgs]);\r\n  useEffect(() => {\r\n    if (cache.current !== copy) {\r\n      cache.current = copy;\r\n    }\r\n  }, [copy]);\r\n  return copy;\r\n}\r\n\r\n// src/query/react/useShallowStableValue.ts\r\nfunction useShallowStableValue(value) {\r\n  const cache = useRef(value);\r\n  useEffect(() => {\r\n    if (!shallowEqual(cache.current, value)) {\r\n      cache.current = value;\r\n    }\r\n  }, [value]);\r\n  return shallowEqual(cache.current, value) ? cache.current : value;\r\n}\r\n\r\n// src/query/react/buildHooks.ts\r\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\r\nvar isDOM = /* @__PURE__ */ canUseDOM();\r\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\r\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\r\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? useLayoutEffect : useEffect;\r\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\r\nvar noPendingQueryStateSelector = (selected) => {\r\n  if (selected.isUninitialized) {\r\n    return {\r\n      ...selected,\r\n      isUninitialized: false,\r\n      isFetching: true,\r\n      isLoading: selected.data !== void 0 ? false : true,\r\n      // This is the one place where we still have to use `QueryStatus` as an enum,\r\n      // since it's the only reference in the React package and not in the core.\r\n      status: QueryStatus.pending\r\n    };\r\n  }\r\n  return selected;\r\n};\r\nfunction pick(obj, ...keys) {\r\n  const ret = {};\r\n  keys.forEach((key) => {\r\n    ret[key] = obj[key];\r\n  });\r\n  return ret;\r\n}\r\nvar COMMON_HOOK_DEBUG_FIELDS = [\"data\", \"status\", \"isLoading\", \"isSuccess\", \"isError\", \"error\"];\r\nfunction buildHooks({\r\n  api,\r\n  moduleOptions: {\r\n    batch,\r\n    hooks: {\r\n      useDispatch,\r\n      useSelector,\r\n      useStore\r\n    },\r\n    unstable__sideEffectsInRender,\r\n    createSelector\r\n  },\r\n  serializeQueryArgs,\r\n  context\r\n}) {\r\n  const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : useEffect;\r\n  const unsubscribePromiseRef = (ref) => ref.current?.unsubscribe?.();\r\n  const endpointDefinitions = context.endpointDefinitions;\r\n  return {\r\n    buildQueryHooks,\r\n    buildInfiniteQueryHooks,\r\n    buildMutationHook,\r\n    usePrefetch\r\n  };\r\n  function queryStatePreSelector(currentState, lastResult, queryArgs) {\r\n    if (lastResult?.endpointName && currentState.isUninitialized) {\r\n      const {\r\n        endpointName\r\n      } = lastResult;\r\n      const endpointDefinition = endpointDefinitions[endpointName];\r\n      if (queryArgs !== skipToken && serializeQueryArgs({\r\n        queryArgs: lastResult.originalArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      }) === serializeQueryArgs({\r\n        queryArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      })) lastResult = void 0;\r\n    }\r\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\r\n    if (data === void 0) data = currentState.data;\r\n    const hasData = data !== void 0;\r\n    const isFetching = currentState.isLoading;\r\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\r\n    const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);\r\n    return {\r\n      ...currentState,\r\n      data,\r\n      currentData: currentState.data,\r\n      isFetching,\r\n      isLoading,\r\n      isSuccess\r\n    };\r\n  }\r\n  function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {\r\n    if (lastResult?.endpointName && currentState.isUninitialized) {\r\n      const {\r\n        endpointName\r\n      } = lastResult;\r\n      const endpointDefinition = endpointDefinitions[endpointName];\r\n      if (queryArgs !== skipToken && serializeQueryArgs({\r\n        queryArgs: lastResult.originalArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      }) === serializeQueryArgs({\r\n        queryArgs,\r\n        endpointDefinition,\r\n        endpointName\r\n      })) lastResult = void 0;\r\n    }\r\n    let data = currentState.isSuccess ? currentState.data : lastResult?.data;\r\n    if (data === void 0) data = currentState.data;\r\n    const hasData = data !== void 0;\r\n    const isFetching = currentState.isLoading;\r\n    const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;\r\n    const isSuccess = currentState.isSuccess || isFetching && hasData;\r\n    return {\r\n      ...currentState,\r\n      data,\r\n      currentData: currentState.data,\r\n      isFetching,\r\n      isLoading,\r\n      isSuccess\r\n    };\r\n  }\r\n  function usePrefetch(endpointName, defaultOptions) {\r\n    const dispatch = useDispatch();\r\n    const stableDefaultOptions = useShallowStableValue(defaultOptions);\r\n    return useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {\r\n      ...stableDefaultOptions,\r\n      ...options\r\n    })), [endpointName, dispatch, stableDefaultOptions]);\r\n  }\r\n  function useQuerySubscriptionCommonImpl(endpointName, arg, {\r\n    refetchOnReconnect,\r\n    refetchOnFocus,\r\n    refetchOnMountOrArgChange,\r\n    skip = false,\r\n    pollingInterval = 0,\r\n    skipPollingIfUnfocused = false,\r\n    ...rest\r\n  } = {}) {\r\n    const {\r\n      initiate\r\n    } = api.endpoints[endpointName];\r\n    const dispatch = useDispatch();\r\n    const subscriptionSelectorsRef = useRef(void 0);\r\n    if (!subscriptionSelectorsRef.current) {\r\n      const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\r\n      if (process.env.NODE_ENV !== \"production\") {\r\n        if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\r\n          throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(37) : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\r\n    You must add the middleware for RTK-Query to function correctly!`);\r\n        }\r\n      }\r\n      subscriptionSelectorsRef.current = returnedValue;\r\n    }\r\n    const stableArg = useStableQueryArgs(skip ? skipToken : arg);\r\n    const stableSubscriptionOptions = useShallowStableValue({\r\n      refetchOnReconnect,\r\n      refetchOnFocus,\r\n      pollingInterval,\r\n      skipPollingIfUnfocused\r\n    });\r\n    const initialPageParam = rest.initialPageParam;\r\n    const stableInitialPageParam = useShallowStableValue(initialPageParam);\r\n    const promiseRef = useRef(void 0);\r\n    let {\r\n      queryCacheKey,\r\n      requestId\r\n    } = promiseRef.current || {};\r\n    let currentRenderHasSubscription = false;\r\n    if (queryCacheKey && requestId) {\r\n      currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\r\n    }\r\n    const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;\r\n    usePossiblyImmediateEffect(() => {\r\n      if (subscriptionRemoved) {\r\n        promiseRef.current = void 0;\r\n      }\r\n    }, [subscriptionRemoved]);\r\n    usePossiblyImmediateEffect(() => {\r\n      const lastPromise = promiseRef.current;\r\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"removeMeOnCompilation\") {\r\n        console.log(subscriptionRemoved);\r\n      }\r\n      if (stableArg === skipToken) {\r\n        lastPromise?.unsubscribe();\r\n        promiseRef.current = void 0;\r\n        return;\r\n      }\r\n      const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\r\n      if (!lastPromise || lastPromise.arg !== stableArg) {\r\n        lastPromise?.unsubscribe();\r\n        const promise = dispatch(initiate(stableArg, {\r\n          subscriptionOptions: stableSubscriptionOptions,\r\n          forceRefetch: refetchOnMountOrArgChange,\r\n          ...isInfiniteQueryDefinition(endpointDefinitions[endpointName]) ? {\r\n            initialPageParam: stableInitialPageParam\r\n          } : {}\r\n        }));\r\n        promiseRef.current = promise;\r\n      } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\r\n        lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\r\n      }\r\n    }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);\r\n    return [promiseRef, dispatch, initiate, stableSubscriptionOptions];\r\n  }\r\n  function buildUseQueryState(endpointName, preSelector) {\r\n    const useQueryState = (arg, {\r\n      skip = false,\r\n      selectFromResult\r\n    } = {}) => {\r\n      const {\r\n        select\r\n      } = api.endpoints[endpointName];\r\n      const stableArg = useStableQueryArgs(skip ? skipToken : arg);\r\n      const lastValue = useRef(void 0);\r\n      const selectDefaultResult = useMemo(() => (\r\n        // Normally ts-ignores are bad and should be avoided, but we're\r\n        // already casting this selector to be `Selector<any>` anyway,\r\n        // so the inconsistencies don't matter here\r\n        // @ts-ignore\r\n        createSelector([\r\n          // @ts-ignore\r\n          select(stableArg),\r\n          (_, lastResult) => lastResult,\r\n          (_) => stableArg\r\n        ], preSelector, {\r\n          memoizeOptions: {\r\n            resultEqualityCheck: shallowEqual\r\n          }\r\n        })\r\n      ), [select, stableArg]);\r\n      const querySelector = useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult, {\r\n        devModeChecks: {\r\n          identityFunctionCheck: \"never\"\r\n        }\r\n      }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);\r\n      const currentState = useSelector((state) => querySelector(state, lastValue.current), shallowEqual);\r\n      const store = useStore();\r\n      const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\r\n      useIsomorphicLayoutEffect(() => {\r\n        lastValue.current = newLastValue;\r\n      }, [newLastValue]);\r\n      return currentState;\r\n    };\r\n    return useQueryState;\r\n  }\r\n  function usePromiseRefUnsubscribeOnUnmount(promiseRef) {\r\n    useEffect(() => {\r\n      return () => {\r\n        unsubscribePromiseRef(promiseRef);\r\n        promiseRef.current = void 0;\r\n      };\r\n    }, [promiseRef]);\r\n  }\r\n  function refetchOrErrorIfUnmounted(promiseRef) {\r\n    if (!promiseRef.current) throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage2(38) : \"Cannot refetch a query that has not been started yet.\");\r\n    return promiseRef.current.refetch();\r\n  }\r\n  function buildQueryHooks(endpointName) {\r\n    const useQuerySubscription = (arg, options = {}) => {\r\n      const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\r\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\r\n      return useMemo(() => ({\r\n        /**\r\n         * A method to manually refetch data for the query\r\n         */\r\n        refetch: () => refetchOrErrorIfUnmounted(promiseRef)\r\n      }), [promiseRef]);\r\n    };\r\n    const useLazyQuerySubscription = ({\r\n      refetchOnReconnect,\r\n      refetchOnFocus,\r\n      pollingInterval = 0,\r\n      skipPollingIfUnfocused = false\r\n    } = {}) => {\r\n      const {\r\n        initiate\r\n      } = api.endpoints[endpointName];\r\n      const dispatch = useDispatch();\r\n      const [arg, setArg] = useState(UNINITIALIZED_VALUE);\r\n      const promiseRef = useRef(void 0);\r\n      const stableSubscriptionOptions = useShallowStableValue({\r\n        refetchOnReconnect,\r\n        refetchOnFocus,\r\n        pollingInterval,\r\n        skipPollingIfUnfocused\r\n      });\r\n      usePossiblyImmediateEffect(() => {\r\n        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\r\n        if (stableSubscriptionOptions !== lastSubscriptionOptions) {\r\n          promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\r\n        }\r\n      }, [stableSubscriptionOptions]);\r\n      const subscriptionOptionsRef = useRef(stableSubscriptionOptions);\r\n      usePossiblyImmediateEffect(() => {\r\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\r\n      }, [stableSubscriptionOptions]);\r\n      const trigger = useCallback(function(arg2, preferCacheValue = false) {\r\n        let promise;\r\n        batch(() => {\r\n          unsubscribePromiseRef(promiseRef);\r\n          promiseRef.current = promise = dispatch(initiate(arg2, {\r\n            subscriptionOptions: subscriptionOptionsRef.current,\r\n            forceRefetch: !preferCacheValue\r\n          }));\r\n          setArg(arg2);\r\n        });\r\n        return promise;\r\n      }, [dispatch, initiate]);\r\n      const reset = useCallback(() => {\r\n        if (promiseRef.current?.queryCacheKey) {\r\n          dispatch(api.internalActions.removeQueryResult({\r\n            queryCacheKey: promiseRef.current?.queryCacheKey\r\n          }));\r\n        }\r\n      }, [dispatch]);\r\n      useEffect(() => {\r\n        return () => {\r\n          unsubscribePromiseRef(promiseRef);\r\n        };\r\n      }, []);\r\n      useEffect(() => {\r\n        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\r\n          trigger(arg, true);\r\n        }\r\n      }, [arg, trigger]);\r\n      return useMemo(() => [trigger, arg, {\r\n        reset\r\n      }], [trigger, arg, reset]);\r\n    };\r\n    const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);\r\n    return {\r\n      useQueryState,\r\n      useQuerySubscription,\r\n      useLazyQuerySubscription,\r\n      useLazyQuery(options) {\r\n        const [trigger, arg, {\r\n          reset\r\n        }] = useLazyQuerySubscription(options);\r\n        const queryStateResults = useQueryState(arg, {\r\n          ...options,\r\n          skip: arg === UNINITIALIZED_VALUE\r\n        });\r\n        const info = useMemo(() => ({\r\n          lastArg: arg\r\n        }), [arg]);\r\n        return useMemo(() => [trigger, {\r\n          ...queryStateResults,\r\n          reset\r\n        }, info], [trigger, queryStateResults, reset, info]);\r\n      },\r\n      useQuery(arg, options) {\r\n        const querySubscriptionResults = useQuerySubscription(arg, options);\r\n        const queryStateResults = useQueryState(arg, {\r\n          selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\r\n          ...options\r\n        });\r\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);\r\n        useDebugValue(debugValue);\r\n        return useMemo(() => ({\r\n          ...queryStateResults,\r\n          ...querySubscriptionResults\r\n        }), [queryStateResults, querySubscriptionResults]);\r\n      }\r\n    };\r\n  }\r\n  function buildInfiniteQueryHooks(endpointName) {\r\n    const useInfiniteQuerySubscription = (arg, options = {}) => {\r\n      const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);\r\n      const subscriptionOptionsRef = useRef(stableSubscriptionOptions);\r\n      usePossiblyImmediateEffect(() => {\r\n        subscriptionOptionsRef.current = stableSubscriptionOptions;\r\n      }, [stableSubscriptionOptions]);\r\n      const trigger = useCallback(function(arg2, direction) {\r\n        let promise;\r\n        batch(() => {\r\n          unsubscribePromiseRef(promiseRef);\r\n          promiseRef.current = promise = dispatch(initiate(arg2, {\r\n            subscriptionOptions: subscriptionOptionsRef.current,\r\n            direction\r\n          }));\r\n        });\r\n        return promise;\r\n      }, [promiseRef, dispatch, initiate]);\r\n      usePromiseRefUnsubscribeOnUnmount(promiseRef);\r\n      const stableArg = useStableQueryArgs(options.skip ? skipToken : arg);\r\n      const refetch = useCallback(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);\r\n      return useMemo(() => {\r\n        const fetchNextPage = () => {\r\n          return trigger(stableArg, \"forward\");\r\n        };\r\n        const fetchPreviousPage = () => {\r\n          return trigger(stableArg, \"backward\");\r\n        };\r\n        return {\r\n          trigger,\r\n          /**\r\n           * A method to manually refetch data for the query\r\n           */\r\n          refetch,\r\n          fetchNextPage,\r\n          fetchPreviousPage\r\n        };\r\n      }, [refetch, trigger, stableArg]);\r\n    };\r\n    const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);\r\n    return {\r\n      useInfiniteQueryState,\r\n      useInfiniteQuerySubscription,\r\n      useInfiniteQuery(arg, options) {\r\n        const {\r\n          refetch,\r\n          fetchNextPage,\r\n          fetchPreviousPage\r\n        } = useInfiniteQuerySubscription(arg, options);\r\n        const queryStateResults = useInfiniteQueryState(arg, {\r\n          selectFromResult: arg === skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\r\n          ...options\r\n        });\r\n        const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, \"hasNextPage\", \"hasPreviousPage\");\r\n        useDebugValue(debugValue);\r\n        return useMemo(() => ({\r\n          ...queryStateResults,\r\n          fetchNextPage,\r\n          fetchPreviousPage,\r\n          refetch\r\n        }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);\r\n      }\r\n    };\r\n  }\r\n  function buildMutationHook(name) {\r\n    return ({\r\n      selectFromResult,\r\n      fixedCacheKey\r\n    } = {}) => {\r\n      const {\r\n        select,\r\n        initiate\r\n      } = api.endpoints[name];\r\n      const dispatch = useDispatch();\r\n      const [promise, setPromise] = useState();\r\n      useEffect(() => () => {\r\n        if (!promise?.arg.fixedCacheKey) {\r\n          promise?.reset();\r\n        }\r\n      }, [promise]);\r\n      const triggerMutation = useCallback(function(arg) {\r\n        const promise2 = dispatch(initiate(arg, {\r\n          fixedCacheKey\r\n        }));\r\n        setPromise(promise2);\r\n        return promise2;\r\n      }, [dispatch, initiate, fixedCacheKey]);\r\n      const {\r\n        requestId\r\n      } = promise || {};\r\n      const selectDefaultResult = useMemo(() => select({\r\n        fixedCacheKey,\r\n        requestId: promise?.requestId\r\n      }), [fixedCacheKey, promise, select]);\r\n      const mutationSelector = useMemo(() => selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);\r\n      const currentState = useSelector(mutationSelector, shallowEqual);\r\n      const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\r\n      const reset = useCallback(() => {\r\n        batch(() => {\r\n          if (promise) {\r\n            setPromise(void 0);\r\n          }\r\n          if (fixedCacheKey) {\r\n            dispatch(api.internalActions.removeMutationResult({\r\n              requestId,\r\n              fixedCacheKey\r\n            }));\r\n          }\r\n        });\r\n      }, [dispatch, fixedCacheKey, promise, requestId]);\r\n      const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, \"endpointName\");\r\n      useDebugValue(debugValue);\r\n      const finalState = useMemo(() => ({\r\n        ...currentState,\r\n        originalArgs,\r\n        reset\r\n      }), [currentState, originalArgs, reset]);\r\n      return useMemo(() => [triggerMutation, finalState], [triggerMutation, finalState]);\r\n    };\r\n  }\r\n}\r\n\r\n// src/query/react/module.ts\r\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\r\nvar reactHooksModule = ({\r\n  batch = rrBatch,\r\n  hooks = {\r\n    useDispatch: rrUseDispatch,\r\n    useSelector: rrUseSelector,\r\n    useStore: rrUseStore\r\n  },\r\n  createSelector = _createSelector,\r\n  unstable__sideEffectsInRender = false,\r\n  ...rest\r\n} = {}) => {\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    const hookNames = [\"useDispatch\", \"useSelector\", \"useStore\"];\r\n    let warned = false;\r\n    for (const hookName of hookNames) {\r\n      if (countObjectKeys(rest) > 0) {\r\n        if (rest[hookName]) {\r\n          if (!warned) {\r\n            console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\r\n            warned = true;\r\n          }\r\n        }\r\n        hooks[hookName] = rest[hookName];\r\n      }\r\n      if (typeof hooks[hookName] !== \"function\") {\r\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage3(36) : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\r\nHook ${hookName} was either not provided or not a function.`);\r\n      }\r\n    }\r\n  }\r\n  return {\r\n    name: reactHooksModuleName,\r\n    init(api, {\r\n      serializeQueryArgs\r\n    }, context) {\r\n      const anyApi = api;\r\n      const {\r\n        buildQueryHooks,\r\n        buildInfiniteQueryHooks,\r\n        buildMutationHook,\r\n        usePrefetch\r\n      } = buildHooks({\r\n        api,\r\n        moduleOptions: {\r\n          batch,\r\n          hooks,\r\n          unstable__sideEffectsInRender,\r\n          createSelector\r\n        },\r\n        serializeQueryArgs,\r\n        context\r\n      });\r\n      safeAssign(anyApi, {\r\n        usePrefetch\r\n      });\r\n      safeAssign(context, {\r\n        batch\r\n      });\r\n      return {\r\n        injectEndpoint(endpointName, definition) {\r\n          if (isQueryDefinition(definition)) {\r\n            const {\r\n              useQuery,\r\n              useLazyQuery,\r\n              useLazyQuerySubscription,\r\n              useQueryState,\r\n              useQuerySubscription\r\n            } = buildQueryHooks(endpointName);\r\n            safeAssign(anyApi.endpoints[endpointName], {\r\n              useQuery,\r\n              useLazyQuery,\r\n              useLazyQuerySubscription,\r\n              useQueryState,\r\n              useQuerySubscription\r\n            });\r\n            api[`use${capitalize(endpointName)}Query`] = useQuery;\r\n            api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\r\n          }\r\n          if (isMutationDefinition(definition)) {\r\n            const useMutation = buildMutationHook(endpointName);\r\n            safeAssign(anyApi.endpoints[endpointName], {\r\n              useMutation\r\n            });\r\n            api[`use${capitalize(endpointName)}Mutation`] = useMutation;\r\n          } else if (isInfiniteQueryDefinition(definition)) {\r\n            const {\r\n              useInfiniteQuery,\r\n              useInfiniteQuerySubscription,\r\n              useInfiniteQueryState\r\n            } = buildInfiniteQueryHooks(endpointName);\r\n            safeAssign(anyApi.endpoints[endpointName], {\r\n              useInfiniteQuery,\r\n              useInfiniteQuerySubscription,\r\n              useInfiniteQueryState\r\n            });\r\n            api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\n// src/query/react/index.ts\r\nexport * from \"@reduxjs/toolkit/query\";\r\n\r\n// src/query/react/ApiProvider.tsx\r\nimport { configureStore, formatProdErrorMessage as _formatProdErrorMessage4 } from \"@reduxjs/toolkit\";\r\nimport * as React from \"react\";\r\nfunction ApiProvider(props) {\r\n  const context = props.context || ReactReduxContext;\r\n  const existingContext = useContext(context);\r\n  if (existingContext) {\r\n    throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage4(35) : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\r\n  }\r\n  const [store] = React.useState(() => configureStore({\r\n    reducer: {\r\n      [props.api.reducerPath]: props.api.reducer\r\n    },\r\n    middleware: (gDM) => gDM().concat(props.api.middleware)\r\n  }));\r\n  useEffect(() => props.setupListeners === false ? void 0 : setupListeners(store.dispatch, props.setupListeners), [props.setupListeners, store.dispatch]);\r\n  return /* @__PURE__ */ React.createElement(Provider, { store, context }, props.children);\r\n}\r\n\r\n// src/query/react/index.ts\r\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());\r\nexport {\r\n  ApiProvider,\r\n  UNINITIALIZED_VALUE,\r\n  createApi,\r\n  reactHooksModule,\r\n  reactHooksModuleName\r\n};\r\n//# sourceMappingURL=rtk-query-react.modern.mjs.map"],"mappings":"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ACjB;GACA,WAAW,EAAE;GACb,iBAAiB;IACf;IACA;IACA;IACA;IACD;GACD,MAAM,EAAE;GACT,CAAC;EACF,MAAM,YAAY,eAAe;GAC/B;GACA;GACA,gBAAgB;GACjB,CAAC;EACF,MAAM,EACJ,qBACA,0BACA,oBACA,4BACA,0BACE;AACJ,eAAW,IAAI,MAAM;GACnB;GACA;GACD,CAAC;EACF,MAAM,EACJ,YACA,oBACA,eACA,gBACA,iBACA,iBACA,UACA,2BACE,YAAY;GACd;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;EACF,MAAM,EACJ,SACA,SAAS,iBACP,WAAW;GACb;GACA;GACA;GACA;GACA;GACA;GACA;GACA,QAAQ;IACN;IACA;IACA;IACA;IACA;IACA;IACD;GACF,CAAC;AACF,eAAW,IAAI,MAAM;GACnB;GACA;GACA;GACA;GACA,eAAe,aAAa;GAC5B,oBAAoB,aAAa;GAClC,CAAC;AACF,eAAW,IAAI,iBAAiB,aAAa;EAC7C,MAAM,mCAAmC,IAAI,SAAS;EACtD,MAAM,oBAAoB,aAAa;AAOrC,UANc,oBAAoB,kBAAkB,iBAAiB;IACnE,sCAAsC,IAAI,KAAK;IAC/C,8BAA8B,IAAI,KAAK;IACvC,gCAAgC,IAAI,KAAK;IACzC,kCAAkC,IAAI,KAAK;IAC5C,EAAE;;EAGL,MAAM,EACJ,oBACA,4BACA,uBACA,yBACA,0BACA,wBACA,yBACE,cAAc;GAChB;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;AACF,eAAW,IAAI,MAAM;GACnB;GACA;GACA;GACA;GACD,CAAC;EACF,MAAM,EACJ,YACA,SAAS,sBACP,gBAAgB;GAClB;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;AACF,eAAW,IAAI,MAAM,kBAAkB;AACvC,eAAW,KAAK;GACd;GACA;GACD,CAAC;AACF,SAAO;GACL,MAAM;GACN,eAAe,cAAc,YAAY;IACvC,MAAM,SAAS;IACf,MAAM,WAAW,OAAO,UAAU,kBAAkB,EAAE;AACtD,QAAIJ,oB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"}